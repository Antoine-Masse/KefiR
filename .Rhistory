devtools::use_package('igraph')
devtools::use_package('psych')
devtools::use_package('stats')
devtools::use_package("stats")
devtools::use_package("stats")
usethis::use_vignette("comment-utiliser-mon-package")
library(KefiR)
#' igraph of correlated variables
#'
#' @param data a data.frame
#' @param pval the maximum permissible p-value for the display
#' @param exclude the minimum threshold of displayed correlations
#' @param ampli coefficient of amplification of vertices
#'
#' @return correlation graph network (igraph) of the variables
#' @import igraph
#' @import psych
#' @importFrom stats na.omit
#' @export
#'
#' @examples
#' data(swiss)
#' corrigraph(swiss)
corrigraph <- function(data,pval=0.01,exclude=0.3, ampli=4) {
# Fonction réalisée par Antoine Massé
# Ctrl Alt Shift R
# Version 01
# Janvier 2021
cor(data) -> cor_matrice
# Matrice of p.values of theses correlations
#require("psych") - corr.test
corr.test(data)$p -> pval_matrice # Matrice des p-values
ifelse(pval_matrice<pval,1,0) -> pval_matrice
pval_matrice* cor_matrice -> mymat
#require(igraph)
net <- graph_from_adjacency_matrix(mymat, weighted=T,mode="lower")
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
net <- delete.edges(net, E(net)[ abs(weight) < exclude ])
E(net)$colour <- ifelse(E(net)$weight<0,"red","blue")
E(net)$weight <- abs(E(net)$weight)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l,vertex.size=sqrt(betweenness(net))*ampli+10,vertex.color="yellow",
edge.arrow.size =0,arrow.mode=0,edge.width=(abs(E(net)$weight)*2)^3, edge.color =E(net)$colour)
}
data(swiss)
corrigraph(swiss)
corrigraph(swiss)
library(kefiR)
source('C:/Users/masse/Desktop/KefiR/KefiR/R/corrigraph.R', encoding = 'UTF-8', echo=TRUE)
#' igraph of correlated variables
#'
#' @param data a data.frame
#' @param pval the maximum permissible p-value for the display
#' @param exclude the minimum threshold of displayed correlations
#' @param ampli coefficient of amplification of vertices
#'
#' @return correlation graph network (igraph) of the variables
#' @import igraph
#' @import psych
#' @importFrom stats na.omit
#' @export
#'
#' @examples
#' data(swiss)
#' corrigraph(swiss)
corrigraph <- function(data,pval=0.01,exclude=0.3, ampli=4) {
# Fonction réalisée par Antoine Massé
# Ctrl Alt Shift R
# Version 01
# Janvier 2021
cor(data) -> cor_matrice
# Matrice of p.values of theses correlations
#require("psych") - corr.test
corr.test(data)$p -> pval_matrice # Matrice des p-values
ifelse(pval_matrice<pval,1,0) -> pval_matrice
pval_matrice* cor_matrice -> mymat
#require(igraph)
net <- graph_from_adjacency_matrix(mymat, weighted=T,mode="lower")
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
net <- delete.edges(net, E(net)[ abs(weight) < exclude ])
E(net)$colour <- ifelse(E(net)$weight<0,"red","blue")
E(net)$weight <- abs(E(net)$weight)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l,vertex.size=sqrt(betweenness(net))*ampli+10,vertex.color="yellow",
edge.arrow.size =0,arrow.mode=0,edge.width=(abs(E(net)$weight)*2)^3, edge.color =E(net)$colour)
}
data(swiss)
corrigraph(swiss)
library(psych)
corrigraph(swiss)
library(igraph)
corrigraph(swiss)
corrigraph(swiss)
devtools::use_package("igraph")
library(devtools)
devtools::use_package("igraph")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(KefiR)
install.packages("usethis")
install.packages("usethis")
library(KefiR)
usethis::use_build_ignore("devtools_history.R")
usethis::use_build_ignore("comment-utiliser-mon-package.Rmd")
devtools::use_package('igraph')
library(usethis)
devtools::use_package('psych')
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#library(KefiR)
#data(swiss)
#corrigraph(airquality)
install.packages("qPDF")
install.packages("qpdf")
# Sélectionner le package tar.gz
#install.packages(file.choose(), repos = NULL, type="source")
library(KefiR)
data(swiss)
corrigraph(swiss)
install.packages("igraph")
valreg <- function(reg,analyse=FALSE,nvar=5) {
error <- "OK"
nvar1 <- length(coef(reg))
if (nvar1 > nvar) {if(analyse==TRUE){cat("Plus de 6 variables\n")};error = "error"
} else if ( (length(summary(reg)[[4]][,4])) != (length(coef(reg))) ) {error = "error"
} else {
raintest(reg)$p.value -> pval # test de rainbow Adequacy
if (pval < 0.05) {if(analyse==TRUE){cat("Bad adequacy.\n")};error = "error"}
dwtest(reg)$p.value -> pval # Independence of DurbinWatson residues
if (pval < 0.05) {if(analyse==TRUE){cat("Bad independence of the residues.\n")};error = "error"}
shapiro.test(residuals(reg))$p.value->pval # Normal distribution of residues
if (pval < 0.05) {if(analyse==TRUE){cat("Non-normal distribution of residues.\n")};error = "error"}
if (length(coef(reg))>=2) {
bptest(reg)$p.value -> pval # Breush Pagan: constant variance of residuals
if (pval < 0.05) {if(analyse==TRUE){cat("Non-constant variance of the residuals.\n")};error = "error"}
}
cooks.distance(reg)->cooksd
if (max(cooksd,na.rm=T) > 1) {if(analyse==TRUE){cat("Leverage effect.\n")};error = "error"}
}
return(error)
}
data(airquality)
reg <- lm(Wind~Temp,data=airquality)
valreg(reg,analyse=T)
library(lmtest) ; library(car)
reg <- lm(Wind~Temp,data=airquality)
valreg(reg,analyse=T)
library(car)
?cooks.distance
