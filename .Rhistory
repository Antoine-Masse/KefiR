devtools::use_package('igraph')
devtools::use_package('psych')
devtools::use_package('stats')
devtools::use_package("stats")
devtools::use_package("stats")
usethis::use_vignette("comment-utiliser-mon-package")
library(KefiR)
#' igraph of correlated variables
#'
#' @param data a data.frame
#' @param pval the maximum permissible p-value for the display
#' @param exclude the minimum threshold of displayed correlations
#' @param ampli coefficient of amplification of vertices
#'
#' @return correlation graph network (igraph) of the variables
#' @import igraph
#' @import psych
#' @importFrom stats na.omit
#' @export
#'
#' @examples
#' data(swiss)
#' corrigraph(swiss)
corrigraph <- function(data,pval=0.01,exclude=0.3, ampli=4) {
# Fonction réalisée par Antoine Massé
# Ctrl Alt Shift R
# Version 01
# Janvier 2021
cor(data) -> cor_matrice
# Matrice of p.values of theses correlations
#require("psych") - corr.test
corr.test(data)$p -> pval_matrice # Matrice des p-values
ifelse(pval_matrice<pval,1,0) -> pval_matrice
pval_matrice* cor_matrice -> mymat
#require(igraph)
net <- graph_from_adjacency_matrix(mymat, weighted=T,mode="lower")
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
net <- delete.edges(net, E(net)[ abs(weight) < exclude ])
E(net)$colour <- ifelse(E(net)$weight<0,"red","blue")
E(net)$weight <- abs(E(net)$weight)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l,vertex.size=sqrt(betweenness(net))*ampli+10,vertex.color="yellow",
edge.arrow.size =0,arrow.mode=0,edge.width=(abs(E(net)$weight)*2)^3, edge.color =E(net)$colour)
}
data(swiss)
corrigraph(swiss)
corrigraph(swiss)
library(kefiR)
source('C:/Users/masse/Desktop/KefiR/KefiR/R/corrigraph.R', encoding = 'UTF-8', echo=TRUE)
#' igraph of correlated variables
#'
#' @param data a data.frame
#' @param pval the maximum permissible p-value for the display
#' @param exclude the minimum threshold of displayed correlations
#' @param ampli coefficient of amplification of vertices
#'
#' @return correlation graph network (igraph) of the variables
#' @import igraph
#' @import psych
#' @importFrom stats na.omit
#' @export
#'
#' @examples
#' data(swiss)
#' corrigraph(swiss)
corrigraph <- function(data,pval=0.01,exclude=0.3, ampli=4) {
# Fonction réalisée par Antoine Massé
# Ctrl Alt Shift R
# Version 01
# Janvier 2021
cor(data) -> cor_matrice
# Matrice of p.values of theses correlations
#require("psych") - corr.test
corr.test(data)$p -> pval_matrice # Matrice des p-values
ifelse(pval_matrice<pval,1,0) -> pval_matrice
pval_matrice* cor_matrice -> mymat
#require(igraph)
net <- graph_from_adjacency_matrix(mymat, weighted=T,mode="lower")
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
net <- delete.edges(net, E(net)[ abs(weight) < exclude ])
E(net)$colour <- ifelse(E(net)$weight<0,"red","blue")
E(net)$weight <- abs(E(net)$weight)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l,vertex.size=sqrt(betweenness(net))*ampli+10,vertex.color="yellow",
edge.arrow.size =0,arrow.mode=0,edge.width=(abs(E(net)$weight)*2)^3, edge.color =E(net)$colour)
}
data(swiss)
corrigraph(swiss)
library(psych)
corrigraph(swiss)
library(igraph)
corrigraph(swiss)
corrigraph(swiss)
devtools::use_package("igraph")
library(devtools)
devtools::use_package("igraph")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(KefiR)
install.packages("usethis")
install.packages("usethis")
library(KefiR)
usethis::use_build_ignore("devtools_history.R")
usethis::use_build_ignore("comment-utiliser-mon-package.Rmd")
devtools::use_package('igraph')
library(usethis)
devtools::use_package('psych')
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#library(KefiR)
#data(swiss)
#corrigraph(airquality)
install.packages("qPDF")
install.packages("qpdf")
# Sélectionner le package tar.gz
#install.packages(file.choose(), repos = NULL, type="source")
library(KefiR)
data(swiss)
corrigraph(swiss)
install.packages("igraph")
valreg <- function(reg,analyse=FALSE,nvar=5) {
error <- "OK"
nvar1 <- length(coef(reg))
if (nvar1 > nvar) {if(analyse==TRUE){cat("Plus de 6 variables\n")};error = "error"
} else if ( (length(summary(reg)[[4]][,4])) != (length(coef(reg))) ) {error = "error"
} else {
raintest(reg)$p.value -> pval # test de rainbow Adequacy
if (pval < 0.05) {if(analyse==TRUE){cat("Bad adequacy.\n")};error = "error"}
dwtest(reg)$p.value -> pval # Independence of DurbinWatson residues
if (pval < 0.05) {if(analyse==TRUE){cat("Bad independence of the residues.\n")};error = "error"}
shapiro.test(residuals(reg))$p.value->pval # Normal distribution of residues
if (pval < 0.05) {if(analyse==TRUE){cat("Non-normal distribution of residues.\n")};error = "error"}
if (length(coef(reg))>=2) {
bptest(reg)$p.value -> pval # Breush Pagan: constant variance of residuals
if (pval < 0.05) {if(analyse==TRUE){cat("Non-constant variance of the residuals.\n")};error = "error"}
}
cooks.distance(reg)->cooksd
if (max(cooksd,na.rm=T) > 1) {if(analyse==TRUE){cat("Leverage effect.\n")};error = "error"}
}
return(error)
}
data(airquality)
reg <- lm(Wind~Temp,data=airquality)
valreg(reg,analyse=T)
library(lmtest) ; library(car)
reg <- lm(Wind~Temp,data=airquality)
valreg(reg,analyse=T)
library(car)
?cooks.distance
identify.ech <- function(mean1,mean2,sd1,sd2,iter=500,conf.level = 0.99,conf=0.95,nmin=10,nmax=1000) {
# Version 02 - 17/11/2020
# par Antoine Masse
conftest <- 0 ;  intervalle <- 1 ; test <- 0 ; nprec <- 0 ;
nmint = nmin ; nmaxt = nmax
while ((intervalle >= 1) & (nprec < nmax) & (test==0)) {
n <- nmint
intervalle <- round((nmaxt-nmint)/9,0)
if (intervalle < 1) {intervalle <-1}
if(intervalle == 1) {test = test+1}
cat("Pas testé : ",intervalle,"\n")
while ((conftest < conf) & (n <= nmax)) {
pval <- c()
for (i in 1:iter) {
pop_ref <- rnorm(n, mean = mean1, sd = sd1)
pop_test <- rnorm(n, mean = mean2, sd = sd2)
pval <- c(pval,t.test(pop_ref,pop_test)$p.value)
}
conftest <- length(pval[pval<(1-conf.level)])/iter
nprec_prec = n-intervalle
nprec <- n
n <- n+intervalle
}
cat("Next loop: from ",nprec_prec," to ",nprec,"\n")
nmint = nprec_prec
nmaxt = nprec
confdef <- conftest
conftest <- 0
}
if (nprec == nmax) {
cat("Warning : The required sample size requires exceeding the maximum population indicated.\n")
} else {cat("To detect an effect under experimental conditions,\nthe population must have a minimum size of : ",nprec,"\n")}
cat("Confidence expected : ",confdef,"\n")
}
identify.ech(mean1 = 100, mean2 = 101, sd1 = 2, sd2 = 3, nmax = 10000)
