noms<- str_split_fixed(noms, "/",2)[,2]
noms
liste_de_fichiers
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
getwd()
setwd("G:/Mon Drive/IUT/biochimie/R3.03_biologie_moléculaire/TP/DN/Rendus");heigh=1.5
setwd("G:/Mon Drive/IUT/biochimie/R3.03_biologie_moléculaire/TP/DN/Rendus");heigh=1.5
#install.packages("readtext")
#install.packages("quanteda")
#install.packages("quanteda.textmodels")
#install.packages("quanteda.textstats")
#install.packages("quanteda.textplots")
#install.packages("ftrCOOL")
library("readtext") # Ouverture de plusieurs documents  de tous les types
library(quanteda) # textmining
quanteda_options(language_stemmer = "french")
library(quanteda.textmodels) # A installer si n�cessaire.
library(quanteda.textmodels)
library("quanteda.textstats")
library("quanteda.textplots")
library("ftrCOOL")
library(stringr)
###############################
#	Ouverture du corpus
###############################
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
annees_de_fichiers <- as.numeric(substring(liste_de_fichiers,1,4))
# Supprimer les fichiers qui n'ont pas d'année
liste_de_fichiers <- liste_de_fichiers[which(!is.na(annees_de_fichiers))]
annees_de_fichiers <- annees_de_fichiers[which(!is.na(annees_de_fichiers))]
# Extraire les noms des rédacteurs
noms<- str_split_fixed(liste_de_fichiers, "_",2)[,1]
noms<- str_split_fixed(noms, "/",2)[,2]
#noms <- c("Gérard Bouchard","Cindy Trintignan","Michel Cohan","Edite Macron",
#	"Jacques Bertrand","Elias Dritsa","Kakior de l'anclo","Noria Ben",
#	"Maria Chymas","Sophie Comtesse")
# Charger le corpus de l'année en cours
P_now <- liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))]
P_now <- readtext(liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))],encoding ="UTF-8")
liste_de_fichiers
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
annees_de_fichiers <- as.numeric(substring(liste_de_fichiers,1,4))
annees_de_fichiers
liste_de_fichiers
getwd()
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
liste_de_fichiers
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
annees_de_fichiers <- as.numeric(substring(liste_de_fichiers,1,4))
# Supprimer les fichiers qui n'ont pas d'année
liste_de_fichiers <- liste_de_fichiers[which(!is.na(annees_de_fichiers))]
annees_de_fichiers <- annees_de_fichiers[which(!is.na(annees_de_fichiers))]
# Extraire les noms des rédacteurs
noms<- str_split_fixed(liste_de_fichiers, "_",2)[,1]
noms<- str_split_fixed(noms, "/",2)[,2]
# Charger le corpus de l'année en cours
P_now <- liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))]
P_now <- readtext(liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))],encoding ="UTF-8")
P_now$doc_id<- noms[annees_de_fichiers ==max(annees_de_fichiers )]
list.files(pattern = ".pdf",recursive = TRUE)
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
liste_de_fichiers
list.files(pattern = ".zip",recursive = TRUE)
c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
liste_de_fichiers
setwd("G:/Mon Drive/IUT/biochimie/R3.03_biologie_moléculaire/TP/AGRO/Rendus");heigh<-2
setwd("G:/Mon Drive/IUT/biochimie/R3.03_biologie_moléculaire/TP/DN/Rendus");heigh=1.5
#install.packages("readtext")
#install.packages("quanteda")
#install.packages("quanteda.textmodels")
#install.packages("quanteda.textstats")
#install.packages("quanteda.textplots")
#install.packages("ftrCOOL")
library("readtext") # Ouverture de plusieurs documents  de tous les types
library(quanteda) # textmining
quanteda_options(language_stemmer = "french")
library(quanteda.textmodels) # A installer si n�cessaire.
library(quanteda.textmodels)
library("quanteda.textstats")
library("quanteda.textplots")
library("ftrCOOL")
library(stringr)
###############################
#	Ouverture du corpus
###############################
# Charger tous les pdf, mais aussi ceux dans des zips
liste_de_fichiers <- c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
annees_de_fichiers <- as.numeric(substring(liste_de_fichiers,1,4))
# Supprimer les fichiers qui n'ont pas d'année
liste_de_fichiers <- liste_de_fichiers[which(!is.na(annees_de_fichiers))]
annees_de_fichiers <- annees_de_fichiers[which(!is.na(annees_de_fichiers))]
# Extraire les noms des rédacteurs
noms<- str_split_fixed(liste_de_fichiers, "_",2)[,1]
noms<- str_split_fixed(noms, "/",2)[,2]
#noms <- c("Gérard Bouchard","Cindy Trintignan","Michel Cohan","Edite Macron",
#	"Jacques Bertrand","Elias Dritsa","Kakior de l'anclo","Noria Ben",
#	"Maria Chymas","Sophie Comtesse")
# Charger le corpus de l'année en cours
P_now <- liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))]
P_now <- readtext(liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))],encoding ="UTF-8")
c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))
liste_de_fichiers
c(list.files(pattern = ".pdf",recursive = TRUE),
list.files(pattern = ".zip",recursive = TRUE))->liste_de_fichiers
liste_de_fichiers
annees_de_fichiers <- as.numeric(substring(liste_de_fichiers,1,4))
# Supprimer les fichiers qui n'ont pas d'année
liste_de_fichiers <- liste_de_fichiers[which(!is.na(annees_de_fichiers))]
annees_de_fichiers <- annees_de_fichiers[which(!is.na(annees_de_fichiers))]
# Extraire les noms des rédacteurs
noms<- str_split_fixed(liste_de_fichiers, "_",2)[,1]
noms<- str_split_fixed(noms, "/",2)[,2]
# Charger le corpus de l'année en cours
P_now <- liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))]
P_now <- readtext(liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))],encoding ="UTF-8")
P_now$doc_id<- noms[annees_de_fichiers ==max(annees_de_fichiers )]
# Charger le corpus de l'année en cours
P_now <- liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))]
P_now
P_now <- readtext(liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))],encoding ="UTF-8")
liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))]
P_now <- readtext(liste_de_fichiers[which(annees_de_fichiers==max(annees_de_fichiers))],encoding ="UTF-8")
remotes::install_github("Antoine-Masse/KefiR",force=TRUE)
install.packages("roxygen2")
install.packages("Rtools")
tools::showNonASCIIfile("R/bootreg.R")
remotes::install_git("Antoine-Masse/KefiR")
library(remotes)
install_git("Antoine-Masse/KefiR")
install_git("Antoine-Masse/KefiR", force=TRUE)
remotes::install_git("Antoine-Masse/KefiR", force=TRUE)
devtools::install_git("Antoine-Masse/KefiR", force=TRUE)
install.packages("remotes") ; require(remotes)
remotes::install_github("Antoine-Masse/KefiR",force=TRUE)
remotes::install_github("Antoine-Masse/KefiR",force=TRUE)
# Répondre à la question (ou CRAN (2) ou,mieux None (3)).
library("KefiR")
3
library(KefiR)
data(iris)
# Créer un modèle mixte
# Modèle avec Petal.Length comme effet fixe et Species comme effet aléatoire
reg_mixed <- lmer(Sepal.Length ~ Petal.Length + (1|Species), data = iris)
data(iris)
# Créer un modèle mixte
# Modèle avec Petal.Length comme effet fixe et Species comme effet aléatoire
reg <- lmer(Sepal.Length ~ Petal.Length + (1|Species), data = iris)
library(lme4)
library(lmerTest)
# Charger les données iris
data(iris)
# Créer un modèle mixte
# Modèle avec Petal.Length comme effet fixe et Species comme effet aléatoire
reg_mixed <- lmer(Sepal.Length ~ Petal.Length + (1|Species), data = iris)
library(lme4)
library(lmerTest)
# Charger les données iris
data(iris)
# Créer un modèle mixte
# Modèle avec Petal.Length comme effet fixe et Species comme effet aléatoire
reg <- lmer(Sepal.Length ~ Petal.Length + (1|Species), data = iris)
valreg(reg)
reg_mixed <- lmer(Reaction ~ Days + (Days | Subject), data = sleepstudy)
get_pvals(reg_mixed=)
devtools::document()
tools::showNonASCIIfile("R/cooks.distance_lmer.R")
R CMD check --no-stop-on-warning KefiR_0.0.1.0.tar.gz
devtools::check(args = "--no-stop-on-warning")
install_git("Antoine-Masse/KefiR",force=TRUE)
remotes::install_git("Antoine-Masse/KefiR",force=TRUE)
devtools::install_git("Antoine-Masse/KefiR",force=TRUE)
devtools::install_git("Antoine-Masse/KefiR",force=TRUE)
remotes::install_git("Antoine-Masse/KefiR",force=TRUE)
remotes::install_git('Antoine-Masse/KefiR')
remotes::install_git('Antoine-Masse/KefiR')
library(remotes)
install_git("Antoine-Masse/KefiR")
install_git("Antoine-Masse/KefiR")
require(devtools) # Risque d'erreur si RTools non installé.
devtools::install_github("Antoine-Masse/KefiR")
3
library(KefiR)
?valreg
# Example 3: Mixed model
library(lme4)
data(iris)
reg_mixed <- lmer(Sepal.Length ~ Petal.Length + (1|Species), data = iris)
valreg(reg_mixed, verbose=TRUE)
# Example 2: Mixed model
library(lme4)
data(sleepstudy)
reg_mixed <- lmer(Reaction ~ Days + (Days | Subject), data = sleepstudy)
valreg(reg_mixed, verbose=TRUE)
?sample
maladie <- sample(c(0,1),20,p=0.3, replace=TRUE)
maladie <- sample(20,c(0,1),p=0.3, replace=TRUE)
maladie <- sample(c(0,1),20,prob=0.3, replace=TRUE)
maladie <- sample(c(0,1),20,prob=c(0.3,0.7), replace=TRUE)
maladie
type <- rep(c('A','B'),each=20)
maladie <- c(sample(c(0,1),20,prob=c(0.3,0.7), replace=TRUE),sample(c(0,1),20,prob=c(0.5,0.5), replace=TRUE))
# Définir les types et les probabilités associées pour la maladie
type <- rep(c('A', 'B'), each = 20)
probs <- list(A = c(0.3, 0.7), B = c(0.5, 0.5))  # Probabilités pour chaque type
# Générer la variable maladie en fonction des probabilités associées à chaque type
maladie <- unlist(Map(function(t, p) sample(c(0, 1), 20, prob = p, replace = TRUE),
type, probs[type]))
# Afficher le résultat
maladie
unlist(maladie)
names(maladie)
names(maladie)<-""
maladie
unname(maldie)
unname(maladie)
table(type,maladie)
# Afficher le résultat
maladie <- unname(maladie)
split(type, type)
set.seed(123)  # Fixer le générateur aléatoire pour la reproductibilité
# Définir les types et les probabilités associées pour la maladie
type <- rep(c('A', 'B'), each = 20)
probs <- list(A = c(0.3, 0.7), B = c(0.5, 0.5))  # Probabilités pour chaque type
# Diviser les types en groupes
split_type <- split(type, type)
# Générer la variable maladie pour chaque groupe de type
maladie <- unlist(Map(function(t, p) sample(c(0, 1), length(t), prob = p, replace = TRUE),
split_type, probs))
# Effacer les noms du vecteur maladie
maladie <- unname(maladie)
# Afficher le résultat
maladie
table(type,maladie)
set.seed(123)  # Fixer le générateur aléatoire pour la reproductibilité
# Définir les types et les probabilités associées pour la maladie
type <- rep(c('A', 'B'), each = 20)
probs <- list(A = c(0.3, 0.7), B = c(0.5, 0.5))  # Probabilités pour chaque type
# Diviser les types en groupes
split_type <- split(type, type)
# Générer la variable maladie pour chaque groupe de type
maladie <- unlist(Map(function(t, p) sample(c(0, 1), length(t), prob = p, replace = TRUE),
split_type, probs))
# Effacer les noms du vecteur maladie
maladie <- unname(maladie)
# Afficher le résultat
maladie
set.seed(123)  # Fixer le générateur aléatoire pour la reproductibilité
# Définir les types et les probabilités associées pour la maladie
type <- rep(c('A', 'B'), each = 20)
probs <- list(A = c(0.3, 0.7), B = c(0.5, 0.5))  # Probabilités pour chaque type
# Diviser les types en groupes
split_type <- split(type, type)
# Générer la variable maladie pour chaque groupe de type
maladie <- unlist(Map(function(t, p) sample(c(0, 1), length(t), prob = p, replace = TRUE),
split_type, probs))
# Effacer les noms du vecteur maladie
maladie <- unname(maladie)
# Afficher le résultat
maladie
table(type,maladie)
set.seed(123)  # Fixer le générateur aléatoire pour la reproductibilité
# Définir les types et les probabilités associées pour la maladie
type <- rep(c('A', 'B'), each = 20)
probs <- list(A = c(0.3, 0.7), B = c(0.5, 0.5))  # Probabilités pour chaque type
# Diviser les types en groupes
split_type <- split(type, type)
# Générer la variable maladie pour chaque groupe de type
maladie <- unlist(Map(function(t, p) sample(c(0, 1), length(t), prob = p, replace = TRUE),
split_type, probs))
# Effacer les noms du vecteur maladie
maladie <- unname(maladie)
# Afficher le résultat
maladie
table(type,maladie)
set.seed(123)  # Fixer le générateur aléatoire pour la reproductibilité
# Définir les types et les probabilités associées pour la maladie
type <- rep(c('A', 'B'), each = 20)
probs <- list(A = c(0.3, 0.7), B = c(0.5, 0.5))  # Probabilités pour chaque type
# Générer la variable maladie en fonction des probabilités associées à chaque type
maladie <- unlist(Map(function(t) sample(c(0, 1), length(t), prob = probs[[t[1]]], replace = TRUE),
split(type, type)))
# Effacer les noms du vecteur maladie
maladie <- unname(maladie)
# Afficher le résultat
maladie
table(type,maladie)
# Générer la variable maladie en fonction des probabilités associées à chaque type
maladie <- unlist(Map(function(t, p) sample(c(0, 1), 20, prob = c(t,p),
replace = TRUE),
type, probs[type]))
dg <- function(n) {
type <- rep(c('A','B'),each=n)
maladie <- c(sample(c(0,1),n,prob=c(0.3,0.7), replace=TRUE),sample(c(0,1),n,prob=c(0.5,0.5), replace=TRUE))
data <- data.frame(type,maladie)
return(data)
}
dg(20)
library(KefiR)
n <- 20
sexe <- rep(c("F","M"),n)
taille <- c(rnorm(20,175.6,7),rnorm(20,162.5,6.4))
t.test(taille,sexe)
taille
taille <- round(c(rnorm(20,175.6,7),rnorm(20,162.5,6.4)),0)
t.test(taille~sexe)
boxplot(taille~sexe)
n <- 20
sexe <- rep(c("M","F"),n)
taille <- round(c(rnorm(20,175.6,7),rnorm(20,162.5,6.4)),0)
boxplot(taille~sexe)
t.test(taille~sexe)
n <- 20
sexe <- rep(c("M","F"),n)
taille <- round(c(rnorm(20,175.6,7),rnorm(20,162.5,6.4)),0)
boxplot(taille~sexe)
t.test(taille~sexe)
n <- 50
sexe <- rep(c("M","F"),n)
taille <- round(c(rnorm(20,175.6,7),rnorm(20,162.5,6.4)),0)
boxplot(taille~sexe)
n <- 50
sexe <- rep(c("M","F"),n)
taille <- round(c(rnorm(n,175.6,7),rnorm(n,162.5,6.4)),0)
boxplot(taille~sexe)
t.test(taille~sexe)
n <- 20
sexe <- rep(c("M","F"),each=n)
taille <- round(c(rnorm(n,175.6,7),rnorm(n,162.5,6.4)),0)
boxplot(taille~sexe)
t.test(taille~sexe)
n <- 20
sexe <- rep(c("M","F"),each=n)
taille <- round(c(rnorm(n,175.6,7),rnorm(n,162.5,6.4)),0)
boxplot(taille~sexe)
t.test(taille~sexe)
# Définir les paramètres de l'analyse
effect_size <- 0.5  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.8        # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
library(pwr)
install.packages("pwr")
# install.packages("pwr")
library(pwr)
# Définir les paramètres de l'analyse
effect_size <- 0.5  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.8        # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
# Afficher le résultat
print(result)
# Fonction pour calculer Cohen's d
calculate_cohens_d <- function(mean1, mean2, sd1, sd2, n1, n2) {
# Calcul de l'écart-type poolé
pooled_sd <- sqrt(((n1 - 1) * sd1^2 + (n2 - 1) * sd2^2) / (n1 + n2 - 2))
# Calcul de Cohen's d
d <- (mean1 - mean2) / pooled_sd
return(d)
}
# Exemple d'utilisation de la fonction
mean1 <- 70
mean2 <- 80
sd1 <- 10
sd2 <- 15
n1 <- 30
n2 <- 30
cohens_d <- calculate_cohens_d(mean1, mean2, sd1, sd2, n1, n2)
print(cohens_d)
# Fonction pour calculer Cohen's d
calculate_cohens_d <- function(mean1, mean2, sd1, sd2, n1, n2) {
# Calcul de l'écart-type poolé
pooled_sd <- sqrt(((n1 - 1) * sd1^2 + (n2 - 1) * sd2^2) / (n1 + n2 - 2))
# Calcul de Cohen's d
d <- (mean1 - mean2) / pooled_sd
return(d)
}
# Exemple d'utilisation de la fonction
mean1 <- 175.6
mean2 <- 162.5
sd1 <- 7
sd2 <- 6.4
n1 <- n
n2 <- n
cohens_d <- calculate_cohens_d(mean1, mean2, sd1, sd2, n1, n2)
print(cohens_d)
n
# install.packages("pwr")
library(pwr)
# Définir les paramètres de l'analyse
effect_size <- 0.95  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.8        # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
# Afficher le résultat
print(result)
# install.packages("pwr")
library(pwr)
# Définir les paramètres de l'analyse
effect_size <- 0.2  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.8        # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
# Afficher le résultat
print(result)
# install.packages("pwr")
library(pwr)
# Définir les paramètres de l'analyse
effect_size <- 0.8  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.8        # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
# Afficher le résultat
print(result)
# install.packages("pwr")
library(pwr)
# Définir les paramètres de l'analyse
effect_size <- 0.8  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.95       # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
# Afficher le résultat
print(result)
for (i in 1:1000 ) {
n <- 20
sexe <- rep(c("M","F"),each=n)
taille <- round(c(rnorm(n,175.6,7),rnorm(n,162.5,6.4)),0)
pval <- c(pval,t.test(taille~sexe)$p.value)
}
pval <- c()
for (i in 1:1000 ) {
n <- 20
sexe <- rep(c("M","F"),each=n)
taille <- round(c(rnorm(n,175.6,7),rnorm(n,162.5,6.4)),0)
pval <- c(pval,t.test(taille~sexe)$p.value)
}
quantile(pval,probs=0.95)
# install.packages("pwr")
library(pwr)
# Définir les paramètres de l'analyse
effect_size <- 0.8  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.95       # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
# Afficher le résultat
print(result)
# install.packages("pwr")
library(pwr)
# Définir les paramètres de l'analyse
effect_size <- 1.95  # Taille de l'effet (Cohen's d)
alpha <- 0.05       # Niveau de signification
power <- 0.95       # Puissance souhaitée
# Analyse de puissance pour un test t de Student à deux échantillons
result <- pwr.t.test(d = effect_size, sig.level = alpha, power = power, type = "two.sample")
# Afficher le résultat
print(result)
pval <- c()
for (i in 1:1000 ) {
n <- 7
sexe <- rep(c("M","F"),each=n)
taille <- round(c(rnorm(n,175.6,7),rnorm(n,162.5,6.4)),0)
pval <- c(pval,t.test(taille~sexe)$p.value)
}
quantile(pval,probs=0.95)
pval <- c()
for (i in 1:1000 ) {
n <- 8
sexe <- rep(c("M","F"),each=n)
taille <- round(c(rnorm(n,175.6,7),rnorm(n,162.5,6.4)),0)
pval <- c(pval,t.test(taille~sexe)$p.value)
}
quantile(pval,probs=0.95)
getwd()
list.files()
usethis::use_testthat(edition = 3)
usethis::use_test("dummy")
devtools::test()
devtools::test()
devtools::test()
devtools::test()
install.packages("rrcov")
devtools::test()
devtools::test()
devtools::test()
devtools::check()
devtools::check()
install.packages("roxygen")
install.packages("roxygen2")
