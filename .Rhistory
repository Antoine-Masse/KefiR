swfr2 <- list("jeu_libre" = c("jeu libre","jeux libres","libre","libres"),"jeu_structure" = c("jeu structure","jeux structures","structure","structures","jeu dirige","jeux diriges","dirige","diriges"),"developpement_de_l'enfant" = c("developpement de l enfant","developpements de l enfant","developpement"),"place_de_l'enseignant" = c("place de l enseignant"),"jeu" = c("jeu","jeux"),"enfant" = c("enfant","enfants")) ; swfr2 <- dictionary(swfr2)
toks_news <- tokens_remove(toks_news, swfr1)
toks_news <- tokens_lookup(toks_news, swfr2,exclusive=F)
#toks_news <- tokens_select(toks_news, pattern=swfr2, selection = "keep")
#toks_news <- tokens_remove(toks_news, swfr2)
my_dfm<- dfm(toks_news,remove=stopwords('fr'),remove_punct=F ,stem=F)
topfeatures(my_dfm,n=50)
textplot_wordcloud(my_dfm,min_count = 20,col=1:7)
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle")
mywd <- mywd[mywd %notin% listeof]
mywd
# Générer une matrice de cooccurrence - Matrice d'associations de mots coocurrences
matx <- t(my_dfm)%*%my_dfm
# Utiliser la fonction match pour ne récupérer que les lignes/colonnes correspondants aux termes retenus en 2)
position <- na.omit(match(rownames(matx),mywd)) # ou inverser les termes de match
matx <- matx[position, position]
nrow(matx)
library(igraph);
g <- graph.adjacency(matx, weighted=T,
mode = "undirected")
plot(g)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
matx
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 1500])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 1200])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 1000])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle","retrouvez","table")
mywd <- mywd[mywd %notin% listeof]
mywd
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle","retrouvez","table","nationale","ecole","maternelle")
mywd <- mywd[mywd %notin% listeof]
mywd
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle","retrouvez","table","nationale","ecole","maternelle","general")
mywd <- mywd[mywd %notin% listeof]
mywd
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 1000])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 200])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
matx
position <- na.omit(match(mywd,rownames(matx)))
matx <- matx[position, position]
nrow(matx)
matx
library(igraph);
g <- graph.adjacency(matx, weighted=T,
mode = "undirected")
plot(g)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 200])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
mymat <- fcm(tn, context = "window", count = "weighted", window = 12,
, ordered = TRUE, tri = FALSE)
positionr <- na.omit(match(mywd,rownames(mymat)))
positionc <- na.omit(match(mywd,colnames(mymat)))
matx <- mymat[positionr, positionc]
nrow(matx) ; matx
mymat <- fcm(tn, context = "window", count = "weighted", window = 20,
, ordered = TRUE, tri = FALSE)
positionr <- na.omit(match(mywd,rownames(mymat)))
positionc <- na.omit(match(mywd,colnames(mymat)))
matx <- mymat[positionr, positionc]
nrow(matx) ; matx
tn <- tokens_lookup(toks_news, mywd, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
dic <- dictionary(mywd)
dic <- dictionary(list(mywd)
tn
dic <- dictionary(list(mywd)
tn <- tokens_lookup(toks_news, mywd, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
dic <- dictionary(list(mywd))
dico_perso <- data.frame(mywd,mywd)
liste <- list()
# Construction de la liste avec les termes du
for(i in 1:nrow(dico_perso)){
# data.fr[i,1] = item; #str_split décompose la seconde col.
#model <- str_replace_all(dico_perso[i,2]," ","")
model <- dico_perso[i,2]
liste[dico_perso[i,1]] <- str_split(model, pattern=',')
}
liste
dic <- dictionary(liste)
```{r}
tn <- tokens_lookup(toks_news, mywd, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
dic
tn <- tokens_lookup(toks_news, mywd, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
dic <- dictionary(liste)
dic <- dictionary(liste)
dic
is(dic)
tn <- tokens_lookup(toks_news, dic, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
mymat <- fcm(tn, context = "window", count = "weighted", window = 20,
, ordered = TRUE, tri = FALSE)
positionr <- na.omit(match(mywd,rownames(mymat)))
positionc <- na.omit(match(mywd,colnames(mymat)))
matx <- mymat[positionr, positionc]
nrow(matx) ; matx
library(igraph);
g <- graph.adjacency(matx, weighted=T,
mode = "undirected")
library(igraph)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- graph_from_adjacency_matrix(matx, weighted=T)
library(igraph)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 200])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
#clp <- cluster_fast_greedy(net)
#clp <- cluster_label_prop(net)
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 1])
plot(clp, net, layout = l, vertex.size=sqrt(betweenness(net))+10)
summary(E(net)$weight)
summary(E(net)$weight)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.5])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
summary(E(net)$weight)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 1])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.4])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
getwd()
png("cluster.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
dev.off()
png("cluster.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
dev.off()
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle","retrouvez","table","nationale","ecole","maternelle","general")
mywd <- mywd[mywd %notin% listeof]
mywd
dico_perso <- data.frame(mywd,mywd)
liste <- list()
# Construction de la liste avec les termes du
for(i in 1:nrow(dico_perso)){
# data.fr[i,1] = item; #str_split décompose la seconde col.
#model <- str_replace_all(dico_perso[i,2]," ","")
model <- dico_perso[i,2]
liste[dico_perso[i,1]] <- str_split(model, pattern=',')
}
liste
dic <- dictionary(liste)
tn <- tokens_lookup(toks_news, dic, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
mymat <- fcm(tn, context = "window", count = "weighted", window = 12,
, ordered = TRUE, tri = FALSE)
positionr <- na.omit(match(mywd,rownames(mymat)))
positionc <- na.omit(match(mywd,colnames(mymat)))
matx <- mymat[positionr, positionc]
nrow(matx) ; matx
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.4])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
getwd()
png("cluster2.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
dev.off()
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.6])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.8])
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 2])
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
getwd()
png("cluster3.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
dev.off()
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle","retrouvez","table","nationale","ecole","maternelle","general")
mywd <- mywd[mywd %notin% listeof]
mywd
dico_perso <- data.frame(mywd,mywd)
liste <- list()
# Construction de la liste avec les termes du
for(i in 1:nrow(dico_perso)){
# data.fr[i,1] = item; #str_split décompose la seconde col.
#model <- str_replace_all(dico_perso[i,2]," ","")
model <- dico_perso[i,2]
liste[dico_perso[i,1]] <- str_split(model, pattern=',')
}
liste
dic <- dictionary(liste)
tn <- tokens_lookup(toks_news, dic, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
mymat <- fcm(tn, context = "window", count = "weighted", window = 9,
, ordered = TRUE, tri = FALSE)
positionr <- na.omit(match(mywd,rownames(mymat)))
positionc <- na.omit(match(mywd,colnames(mymat)))
matx <- mymat[positionr, positionc]
nrow(matx) ; matx
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.5])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
getwd()
png("cluster3.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
dev.off()
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle","retrouvez","table","nationale","ecole","maternelle","general")
mywd <- mywd[mywd %notin% listeof]
mywd <- c(mywd,"developpement_de_l'enfant","place_de_l'enseignant")
dico_perso <- data.frame(mywd,mywd)
liste <- list()
# Construction de la liste avec les termes du
for(i in 1:nrow(dico_perso)){
# data.fr[i,1] = item; #str_split décompose la seconde col.
#model <- str_replace_all(dico_perso[i,2]," ","")
model <- dico_perso[i,2]
liste[dico_perso[i,1]] <- str_split(model, pattern=',')
}
liste
dic <- dictionary(liste)
tn <- tokens_lookup(toks_news, dic, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
mymat <- fcm(tn, context = "window", count = "weighted", window = 9,
, ordered = TRUE, tri = FALSE)
positionr <- na.omit(match(mywd,rownames(mymat)))
positionc <- na.omit(match(mywd,colnames(mymat)))
matx <- mymat[positionr, positionc]
nrow(matx) ; matx
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
plot(net ,vertex.size=sqrt(betweenness(net))+10,vertex.color="green",
edge.arrow.size =0,arrow.mode=0,edge.color="black")
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.5])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
getwd()
png("cluster4.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
dev.off()
taille = 30
tsf <- textstat_frequency(my_dfm,n=taille)
mywd <- tsf$feature
'%notin%' <- Negate('%in%')
listeof <- c("ministere","education","superieur","httpeduscoleducationfrressourcesmaternelle","retrouvez","table","nationale","ecole","maternelle","general")
mywd <- mywd[mywd %notin% listeof]
mywd <- c(mywd,"place_de_l'enseignant")
dico_perso <- data.frame(mywd,mywd)
liste <- list()
# Construction de la liste avec les termes du
for(i in 1:nrow(dico_perso)){
# data.fr[i,1] = item; #str_split décompose la seconde col.
#model <- str_replace_all(dico_perso[i,2]," ","")
model <- dico_perso[i,2]
liste[dico_perso[i,1]] <- str_split(model, pattern=',')
}
liste
dic <- dictionary(liste)
tn <- tokens_lookup(toks_news, dic, exclusive=T, levels=1:2, nomatch = "_UNMATCHED")
mymat <- fcm(tn, context = "window", count = "weighted", window = 11,
, ordered = TRUE, tri = FALSE)
positionr <- na.omit(match(mywd,rownames(mymat)))
positionc <- na.omit(match(mywd,colnames(mymat)))
matx <- mymat[positionr, positionc]
nrow(matx) ; matx
library(igraph)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
library(igraph)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
plot(clp, net, layout = l, vertex.size=(betweenness(net))+10)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.5])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
getwd()
png("cluster4.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))*2+2)
dev.off()
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.5])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
class(clp)
l <- layout_with_fr(net)
getwd()
png("cluster4.png",width=1024,height=800)
plot(clp, net, layout = l, vertex.size=(betweenness(net))*2+10)
dev.off()
E(net)$weight <- abs((E(net)$weight-max(E(net)$weight))/E(net)$weight)
summary(E(net)$weight)
E(net)$weight <- abs((E(net)$weight-max(E(net)$weight))/E(net)$weight)
summary(E(net)$weight)
net <- graph_from_adjacency_matrix(matx, weighted=T)
net <- simplify(net, remove.multiple = T, remove.loops = TRUE) # élaguer les liens redondants
E(net)$arrow.size <- 0 # Exemple de sauvegarde d'un paramètre qu'on aurait plus ainsi à mettre dans comme paramètre de plot comme c'est le cas ci-dessous...
E(net)$edge.color <- "black"
summary(E(net)$weight)
E(net)$weight <- abs((E(net)$weight-max(E(net)$weight))/max(E(net)$weight))
summary(E(net)$weight)
hist(E(net)$weight,breaks=20)
net <- delete.edges(net, E(net)[ abs(E(net)$weight) < 0.7])
# Afficher le tout en tenant compte avec betweenness du poids relatifs d'un mot pour lui donner une taille
clp <- cluster_optimal(net)
