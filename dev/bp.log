================================================================================
GUIDE DES BONNES PRATIQUES - PACKAGE KefiR
================================================================================
Version: 2.0 (restructuré)
Date création: 2025-11-04
Date restructuration: 2026-02-08
Auteur: Antoine Massé

Ce document recense les consignes à suivre lors du développement du package
KefiR pour maintenir cohérence, qualité et maintenabilité.

================================================================================
TABLE DES MATIÈRES
================================================================================
1. Structure et organisation du code
2. Style de code
3. Gestion des paramètres
4. Tests et validation
5. Post-hocs et comparaisons multiples
6. Messages et communication
7. Mode code (code=TRUE)
8. Gestion des formules
9. Packages et dépendances
10. Versioning et archivage
11. Références académiques
12. Checklist avant commit
13. Ordre logique traitement ANCOVA
14. CATALOGUE DES BONNES PRATIQUES (BP-001 à BP-044)
15. CHECKLIST UNIFIÉE
16. HISTORIQUE DES MODIFICATIONS
================================================================================

================================================================================
1. STRUCTURE ET ORGANISATION DU CODE
================================================================================

## 1.1 Nomenclature des fichiers

### Fonctions cachées (usage interne uniquement):
- Préfixe: point (.)
- Exemples: .one_factor_analysis.R, .posthoc.R, .vbse.R
- Ces fonctions NE DOIVENT PAS être exportées dans NAMESPACE

### Fonctions publiques (exposées à l'utilisateur):
- Pas de préfixe
- Exemples: m.test.R, valreg.R, simul.R
- Doivent être exportées dans NAMESPACE
- Doivent avoir documentation Roxygen complète

### Fichiers de test:
- Préfixe: test_ (à éviter en production)
- À terme: tout consolider dans .testeur_m.test()
- Les fichiers test_*.R doivent être dans tests/ ou supprimés après consolidation

## 1.2 Structure des répertoires

KefiR/
├── R/                      # Code source
│   ├── v0.0.1.0/          # Archives versions précédentes
│   ├── v0.0.1.1/          # Version en cours d'archivage
│   └── *.R                # Fichiers actifs
├── R_poubelle/            # Fonctions obsolètes avant suppression/archivage
├── man/                   # Documentation générée (Roxygen)
├── tests/                 # Tests unitaires
├── vignettes/             # Documentation utilisateur
├── kefir.log             # Journal développement à mettre à jour systématiquement
├── bp.log                # Ce fichier (bonnes pratiques)
└── DESCRIPTION           # Métadonnées package

================================================================================
2. STYLE DE CODE
================================================================================

## 2.1 Conventions de nommage

### Variables et paramètres:
- snake_case pour variables internes: `check_normality`, `test_statistics`
- Points autorisés pour compatibilité R: `var.equal`, `p.value`

### Fonctions:
- snake_case avec point initial si cachée: `.multi_factor_analysis()`
- Éviter camelCase sauf pour packages externes

### Constantes:
- UPPERCASE avec underscore: `MAX_GROUPS`, `DEFAULT_ALPHA`

## 2.2 Commentaires et documentation

### Commentaires de code:
```r
# NOTE PERSO: Pour expliquer choix d'implémentation complexes
# TODO: Pour actions à faire
# FIXME: Pour bugs connus à corriger
# IMPORTANT: Pour avertissements critiques
```

### Messages utilisateur (.vbse):
- Bilingues: EN/FR
- Pédagogiques: expliquer le "pourquoi", pas seulement le "quoi"
- Références académiques quand approprié
- Format: `k <- .vbse("EN message", "FR message", verbose=verbose, k=k, cpt="on")`

### Roxygen documentation:
```r
#' @title Titre court
#' @description Description détaillée
#' @param x Description du paramètre
#' @return Description du retour
#' @details Détails d'implémentation
#' @references Références académiques avec DOI
#' @examples
#' # Exemples exécutables
#' @export (si fonction publique uniquement)
```

================================================================================
3. GESTION DES PARAMÈTRES
================================================================================

## 3.1 Paramètres standard m.test() et sous-fonctions

### Paramètres essentiels:
- `x`: Variable(s) dépendante(s) - vecteur ou matrice
- `g`: Variable(s) de groupement - facteur ou data.frame
- `formula`: Interface formule (alternative à x/g)
- `data`: Data frame source

### Paramètres de contrôle:
- `alpha`: Seuil significativité (défaut: 0.05)
- `paired`: Booléen pour données appariées (défaut: FALSE)
- `id`: Variable identificateur pour paired=TRUE

### Paramètres de sortie:
- `verbose`: Affichage messages pédagogiques (défaut: FALSE si return=FALSE, sinon TRUE)
- `plot`: Affichage graphiques (défaut: FALSE si return=FALSE, sinon TRUE)
- `code`: Affichage code R reproductible (défaut: FALSE)
- `return`: Type de sortie (TRUE=bilan complet, FALSE=p-value uniquement)
- `debug`: Messages debug pour développement (défaut: FALSE)

### Paramètre interne:
- `k`: Compteur messages .vbse() (initialisé à NULL, devient 0 si NULL)

## 3.2 Cohérence des paramètres

RÈGLE IMPORTANTE - Comportement de return=FALSE:
```r
if (return == FALSE) {
  # Mode automatique pour boucles : désactiver toutes les sorties auxiliaires
  if (missing(verbose)) verbose <- FALSE  # Pas de messages pédagogiques
  if (missing(plot)) plot <- FALSE        # Pas de graphiques
  if (missing(code)) code <- FALSE        # Pas de code R reproductible

  # Retourner UNIQUEMENT la p-value du test GLOBAL (scalaire numérique)
  # NE PAS faire de post-hocs
  # NE PAS retourner de structure de données complexe
}
```

**P-value globale retournée selon le contexte**:
- **2 groupes** : p-value du test bivarié (t.test, wilcox.test, brunner.munzel.test)
- **3+ groupes** : p-value globale du test omnibus
  - ANOVA classique : p-value F-test de aov()
  - ANOVA robuste : p-value Kruskal-Wallis ou Welch
  - MANOVA : p-value Pillai/Wilks (minimum des 4 tests)
  - ANCOVA : p-value F-test global de l'ANCOVA
  - Modèles mixtes : p-value de l'effet fixe principal

================================================================================
4. TESTS ET VALIDATION
================================================================================

## 4.1 Tests d'assomptions

### Tests de normalité:
- Utiliser .normality() avec modes: "normal", "extrem", "forced"
- Documenter références: Shapiro-Wilk, Jarque-Bera, etc.
- Justifier choix du mode selon contexte

### Tests d'homogénéité:
- Levene pour ANOVA
- Box's M pour MANOVA
- Documenter sensibilité et seuils

### Autres assomptions:
- Indépendance: rappel méthodologique
- Linéarité: tests appropriés selon contexte
- Outliers et Influence: voir section 4.1.1 ci-dessous

### 4.1.1 Diagnostics d'outliers et d'influence

**RÈGLE GÉNÉRALE**: Distinguer outliers marginaux (IQR-based) et observations influentes (géométrie modèle).

**Deux approches complémentaires**:

A) **Outliers marginaux** [identify_outliers() {rstatix}]
   - Méthode: IQR-based (Q1 - 1.5×IQR, Q3 + 1.5×IQR)
   - Détection: Valeurs extrêmes dans distributions univariées
   - Usage: Screening initial, indépendant du modèle

B) **Influence sur le modèle** [.diagnostic_influence()]
   - Trois métriques académiques combinées:

     1. **Cook's Distance** [cooks.distance() {stats}]
        - Formule: leverage × résidu standardisé²
        - Seuil conservateur: 4/n (Fox 2016)
        - Seuil critique: > 1
        - Interprétation: Impact global sur TOUS les coefficients β

     2. **Leverage (hat values)** [hatvalues() {stats}]
        - Seuil: 2p/n où p = nombre de paramètres
        - Interprétation: Distance dans espace prédicteurs

     3. **DFBETAS** [dfbetas() {stats}]
        - Seuil: 2/√n (Belsley et al. 1980)
        - Interprétation: Impact sur CHAQUE coefficient individuellement

## 4.2 Approches robustes

TOUJOURS proposer alternatives robustes si assomptions violées:
- Tests non-paramétriques (Kruskal-Wallis, etc.)
- Bootstrap
- Permutations
- Estimateurs robustes (MCD, etc.)

## 4.3 Tests de non-régression

Avant CHAQUE commit majeur:
1. Exécuter .testeur_m.test() complet
2. Vérifier 100% tests passés
3. Archiver scripts dans R/v{version}/
4. Mettre à jour kefir.log

================================================================================
5. POST-HOCS ET COMPARAISONS MULTIPLES
================================================================================

## 5.1 Post-hocs ANOVA (.posthoc.R)

### Approche paramétrique (var.equal=TRUE):
- Tukey HSD
- SNK (Student-Newman-Keuls)
- Scheffe

### Approche non-paramétrique (var.equal=FALSE):
- Games-Howell
- Dunnett T3

### Corrections:
- Bonferroni si peu de comparaisons
- Holm si nombreuses comparaisons

## 5.2 Post-hocs MANOVA (.posthoc_MANOVA.R)

IMPORTANT: Post-hocs univariés classiques INAPPROPRIÉS pour MANOVA

### Approches recommandées:
1. **Analyse discriminante** (prioritaire)
   - MASS::lda()
   - Structure matrix (corrélations VD × LD)
   - Identifier quelles VD séparent groupes

2. **ANOVAs univariées protégées**
   - Une ANOVA par VD
   - Correction Bonferroni: alpha_adj = alpha / p
   - UNIQUEMENT après MANOVA significative

## 5.3 Post-hocs ANCOVA (.posthoc_ANCOVA.R)

Logique académique implémentée:
- Comparaisons à covariables ajustées
- Emmeans avec correction Tukey (défaut)
- Documentation des limitations

## 5.4 Post-hocs Modèles Mixtes (.posthoc_mixed_model.R)

IMPORTANT: Post-hocs classiques INAPPROPRIÉS pour modèles mixtes

### Approche recommandée:
1. **Moyennes marginales estimées (EMMs)**
   - Package emmeans
   - Compte pour structure effets aléatoires
   - Ajusté pour designs déséquilibrés

2. **Conditions d'exécution**:
   - UNIQUEMENT si au moins un effet fixe significatif
   - Pas de post-hocs si aucun effet significatif détecté

================================================================================
6. MESSAGES ET COMMUNICATION
================================================================================

## 6.1 Hiérarchie des messages

### .dbg() - Debug:
- Usage: Développement uniquement
- Condition: `if (debug == TRUE)`
- Bilingue: Oui

### .vbse() - Verbose:
- Usage: Messages pédagogiques utilisateur
- Condition: `if (verbose == TRUE)`
- Compteur: k incrémenté
- Bilingue: Oui

### .msg() - Messages critiques:
- Usage: Avertissements importants toujours affichés
- Bilingue: Oui

### .exit() - Erreurs:
- Usage: Erreurs bloquantes
- Arrête exécution
- Bilingue: Oui

## 6.2 Format des messages verbose

```r
k <- .vbse(
  paste0("TITRE SECTION\n",
         "\tDétail 1\n",
         "\tDétail 2\n",
         "\tConclusion"),
  paste0("TITRE SECTION\n",
         "\tDétail 1\n",
         "\tDétail 2\n",
         "\tConclusion"),
  verbose = verbose, k = k, cpt = "on"
)
```

Règles de base:
- \t pour indentation
- \n pour retours ligne
- Sections en MAJUSCULES
- Détails concis et pédagogiques

## 6.3 Niveaux hiérarchiques avec cpt="off"

**RÈGLE IMPORTANTE**: Quand `cpt="off"`, .vbse() ajoute automatiquement
UNE TABULATION devant la PREMIÈRE LIGNE uniquement.

**Niveaux d'indentation résultants:**
- Sous-titres (a), b), c)...) : AUCUN \t → résultat = 1 tabulation (auto)
- Sous-lignes (==>) : DEUX \t → résultat = 2 tabulations
- Détails supplémentaires : TROIS \t → résultat = 3 tabulations

## 6.4 Formatage pour fenêtres étroites

RÈGLE CRITIQUE: Messages ≤ 80 caractères par ligne

✓ BON:
```r
k <- .vbse(
  paste0("Test KS sur données centrées/réduites:\n",
         "\tDistributions différentes (p = 0.001)\n",
         "\tComparaison avec alpha Sidak = 0.025"),
  verbose = verbose, k = k
)
```

================================================================================
7. MODE CODE (code=TRUE)
================================================================================

## 7.1 Objectif

Générer script R reproductible commenté pour:
- Aider utilisateur à comprendre analyses
- Permettre vérification par pairs
- Faciliter apprentissage R

## 7.2 Principe de minimalisme

**PRINCIPE**: Le code=TRUE ne doit PAS se substituer au verbose.
Il doit juste aider l'utilisateur à reproduire le verbose avec son propre code.

- ✅ Garder: Titres numérotés des étapes
- ✅ Garder: Code R exécutable essentiel
- ❌ Supprimer: Détails déjà expliqués dans verbose
- ❌ Supprimer: Commentaires pédagogiques redondants
- ❌ Supprimer: Arborescences de décision

## 7.3 Interdictions critiques mode code

❌ **INTERDIT 1: Dupliquer les appels**
❌ **INTERDIT 2: Charger library(KefiR)**
❌ **INTERDIT 3: Variables placeholder non utilisables**
❌ **INTERDIT 4: Commentaires en anglais** (sauf si langue=EN)
❌ **INTERDIT 5: Sauts de ligne anarchiques**
❌ **INTERDIT 6: Manque de correspondance avec verbose**

## 7.4 Références bibliographiques : JAMAIS en verbose

**RÈGLE ABSOLUE**: Les références académiques ne doivent JAMAIS apparaître
dans les messages verbose. Elles sont UNIQUEMENT pour les commentaires de code.

✓ BON:
```r
# Référence: Wilcox (2017). Introduction to Robust Estimation.
.vbse("Méthode robuste sélectionnée : MM-estimation", ...)
```

❌ MAUVAIS:
```r
.vbse("Méthode robuste (Wilcox, 2017) sélectionnée", ...)
```

## 7.5 Normalisation des sorties return=TRUE

**Structure MINIMALE OBLIGATOIRE**:
```r
result <- list(
  p_value = numeric,        # P-value du test global
  method = character,       # Nom du test utilisé
  groups = data.frame,      # Lettres/groupes homogènes
  model = object,           # Modèle statistique (optionnel)
  pairwise = data.frame     # Comparaisons par paires (optionnel)
)
```

================================================================================
8. GESTION DES FORMULES
================================================================================

## 8.1 Formats supportés

```r
# Format 1: Vecteurs directs
m.test(data$A, data$F)

# Format 2: Formule avec data=
m.test(A ~ F, data=data)

# Format 3: MANOVA
m.test(cbind(A,B,C) ~ F, data=data)

# Format 4: Multi-facteurs
m.test(A ~ F * G, data=data)  # Avec interaction
```

## 8.2 Traitement interne

Utiliser fonctions:
- `.normalize_from_formula()`
- `.normalize_formula_dollar()`
- `.formulator()` / `.formulator_safe()`
- `.strip_data_dollar_safe()`

================================================================================
9. PACKAGES ET DÉPENDANCES
================================================================================

## 9.1 Packages requis (Imports)

- stats: Tests statistiques de base
- MASS: Analyse discriminante
- car: ANCOVA, tests avancés
- agricolae: Post-hocs, tests agricoles
- lme4, lmerTest: Modèles mixtes
- WRS2: Tests robustes

## 9.2 Packages suggérés (Suggests)

- MVN: Tests normalité multivariée
- biotools: Box's M test
- rrcov: Méthodes robustes multivariées
- rstatix: Tests modernes

## 9.3 Gestion packages manquants

```r
if (requireNamespace("package", quietly = TRUE)) {
  fonction <- package::fonction
} else {
  warning("Package 'xxx' recommandé. Install: install.packages('xxx')")
}
```

================================================================================
10. VERSIONING ET ARCHIVAGE
================================================================================

## 10.1 Numérotation versions

Format: MAJOR.MINOR.PATCH.BUILD
- MAJOR: Changements incompatibles API
- MINOR: Nouvelles fonctionnalités compatibles
- PATCH: Corrections bugs
- BUILD: Itérations internes

## 10.2 Archivage

À chaque fin de session majeure:
1. Créer R/v{version}/
2. Copier TOUS les fichiers .R modifiés
3. Mettre à jour kefir.log
4. Commit Git avec message détaillé

================================================================================
11. RÉFÉRENCES ACADÉMIQUES
================================================================================

TOUJOURS citer sources pour:
- Choix de tests statistiques
- Seuils critiques
- Approches méthodologiques

Format préféré:
```r
# Reference: Author(s) (Year). Title. Journal, volume(issue), pages.
# DOI: https://doi.org/xxx ou ISBN: xxx
```

Références clés:
- Field et al. (2012): Discovering Statistics Using R
- Tabachnick & Fidell (2019): Using Multivariate Statistics
- Huberty & Olejnik (2006): Applied MANOVA
- Stevens (2009): Applied Multivariate Statistics

================================================================================
12. CHECKLIST AVANT COMMIT
================================================================================

Avant chaque commit important:

[ ] Tous les tests .testeur_m.test() passent
[ ] Documentation Roxygen à jour
[ ] Messages .vbse() bilingues et pédagogiques
[ ] Références académiques pour nouveaux tests
[ ] kefir.log mis à jour
[ ] Pas de browser() ou print() de debug
[ ] Code formaté et commenté
[ ] DESCRIPTION à jour (dépendances, version)

================================================================================
13. ORDRE LOGIQUE DE TRAITEMENT ANCOVA
================================================================================

## 13.1 Détection préliminaire du type de modèle

AVANT toute vérification d'assomption, m.test() doit déterminer le type de
modèle via `.analyze_ancova_structure()` :

### Cas 1: ANCOVA classique (pentes parallèles)
- Formule: A ~ F + B  (PAS d'interaction facteur×covariable)
- Assomptions: 5 (indépendance, normalité, homoscédasticité, linéarité, homogénéité pentes)
- Post-hocs: Moyennes ajustées via emmeans

### Cas 2: Modèle à pentes hétérogènes
- Formule: A ~ F * B  (AVEC interaction facteur×covariable)
- Assomptions: 4 (indépendance, normalité, homoscédasticité, linéarité)
- Post-hocs: Simple effects, Johnson-Neyman

## 13.2 Numérotation dynamique des assomptions

**RÈGLE CRITIQUE**: La numérotation DOIT s'adapter au type de modèle

```r
n_assumptions <- if(has_factor_cov_interaction) 4 else 5
paste0("ASSUMPTION 1/", n_assumptions, ": Independence...")
```

================================================================================
14. CATALOGUE DES BONNES PRATIQUES (BP-001 à BP-044)
================================================================================

Les bonnes pratiques sont organisées par thème pour faciliter la consultation.

---

## 14.1 MESSAGES ET FORMAT

### BP-001: Messages directionnels cohérents
Chaque changement de direction méthodologique doit être explicite :
- ✓ "--> Vers test non-paramétrique"
- ✓ "--> Retour vers test paramétrique"
- ✓ "--> Passage vers approche robuste"
- ✗ Silence (l'utilisateur ne comprend pas le changement)

**Cas spécial**: Après un re-contrôle avec tolérance:
- Verdict CHANGE (FALSE → TRUE): "--> Retour vers test paramétrique"
- Verdict RESTE (FALSE → FALSE): "--> On reste sur test non paramétrique"

### BP-002: Ponctuation des messages
Tous les messages complets doivent se terminer par un point.
- Messages complets (phrases): **Point final obligatoire**
- Lignes de données/résultats isolés: Pas de point

### BP-003: Orthographe et accords
Vérification systématique:
- "données" (2 'n', pas 3)
- Accords pluriel/singulier: "variances hétérogènes"
- Accents français corrects

### BP-004: Format des listes à puces
Pour énumérations ≥ 3 éléments, utiliser puces `•` avec `\n\t  •`
```r
paste0("Vérifiez que :\n",
       "\t  • Pas de mesures répétées\n",
       "\t  • Pas d'effet cluster\n",
       "\t  • Pas d'effets report")
```

### BP-005: Recommandations utilisateur entre parenthèses
Les recommandations, suggestions ou avertissements (actions à faire) doivent
être formatés avec tabulation et entre parenthèses.
```r
"--> Le test MWW sera moins fiable.\n\t",
"(Vérifiez graphiquement que les groupes ont la même distribution.)"
```

---

## 14.2 OBJETS DE RETOUR

### BP-006: Objets de retour complets
TOUTES les fonctions doivent retourner un objet structuré complet,
MÊME dans les cas particuliers (ex: 2 groupes).

**return=TRUE doit TOUJOURS retourner**:
- Structure minimale : `$groups`, `$p.value`, `$method`
- Pas de `NULL` sauf erreur critique
- Cohérence entre tous types d'analyses

---

## 14.3 GRAPHIQUES

### BP-007: Reset layout graphique
Toute fonction produisant un graphique doit réinitialiser le layout
pour éviter problèmes avec `par(mfrow=c(x,y))` précédents.

```r
.plot_with_letters <- function(...) {
  old_par <- par(no.readonly = TRUE)
  on.exit(par(old_par), add = TRUE)
  par(mfrow = c(1, 1))
  # ... reste de la fonction
}
```

---

## 14.4 RÉFÉRENCES BIBLIOGRAPHIQUES

### BP-008: Références en commentaires uniquement
**JAMAIS dans verbose** :
- ❌ "(Chaffin et al. 1993)"
- ❌ "Reference: Maxwell & Delaney (2018)"

**TOUJOURS dans commentaires** :
- ✓ Format APA complet
- ✓ DOI ou ISBN
- ✓ Pages précises si applicable

---

## 14.5 PROCÉDURES

### BP-009: Utiliser load_all_kefir() pour recharger le package
**IMPORTANT**: NE PAS utiliser `devtools::load_all()` directement.

```r
# ✓ TOUJOURS faire:
load_all_kefir()

# ❌ NE PAS faire:
setwd("C:/Users/masse/Desktop/KefiR")
devtools::load_all("KefiR")
```

---

## 14.6 STRUCTURE DES ÉTAPES

### BP-010: Format standard des contrôles académiques
```r
"Contrôle ACADÉMIQUE de [ce qui est contrôlé]."
```
- "Contrôle ACADÉMIQUE de la normalité des résidus du modèle ANOVA."
- "Contrôle ACADÉMIQUE de l'homogénéité de la variance des groupes."

### BP-011: Annonce de l'ajustement du modèle
Pour les ANOVA/analyses multi-groupes, annoncer explicitement l'ajustement
du modèle avant les contrôles de résidus.
```r
"Ajustement du modèle ANOVA [aov()]."
// puis
"Contrôle ACADÉMIQUE de la normalité des résidus du modèle ANOVA."
```

### BP-012: Éviter étapes redondantes
Si une fonction appelée (ex: `.posthoc()`) affiche déjà son propre titre
d'étape, l'appelant ne doit PAS afficher un titre général redondant.

---

## 14.7 LOGIQUE POST-HOCS

### BP-013: Post-hocs TOUJOURS effectués dans KefiR
**Philosophie KefiR**: Les tests post-hoc sont **TOUJOURS** effectués et
affichés, indépendamment de la significativité du test global.

- Test global significatif → Post-hocs effectués
- Test global non significatif → Post-hocs effectués **QUAND MÊME**

**Justification**:
1. Vue complète pour l'utilisateur
2. Transparence (cohérence résultats globaux/post-hocs)
3. Pédagogique (voir quand post-hocs et test global divergent)

---

## 14.8 CORRECTIONS TECHNIQUES CODE R

### BP-014: do.call() avec noms de colonnes
Avec `do.call()`, tout argument qui référence un **nom de colonne** doit
être passé via `as.name("nom_colonne")`.

```r
# ✓ BON
ez_args <- list(
  data = ez_data,
  dv = as.name("DV"),
  wid = as.name("id")
)
result <- do.call(ez::ezANOVA, ez_args)

# ❌ MAUVAIS
ez_args <- list(dv = DV, wid = id)  # Erreur "objet introuvable"
```

### BP-015: Éviter espaces inutiles avec paste()
Utiliser **`paste0()`** par défaut pour tous les messages formatés.
Réserver **`paste()`** UNIQUEMENT quand on veut explicitement des espaces.

### BP-016: Préférer rstatix::anova_test() à ezANOVA
Pour ANOVA mesures répétées avec test de Mauchly, utiliser rstatix::anova_test()
au lieu d'ezANOVA (NSE plus robuste avec rlang).

---

## 14.9 PROTECTION NA

### BP-017: Protection NA dans comparaisons booléennes
Quand une comparaison peut retourner NA, utiliser `isTRUE()` ou vérifier
`!is.na()` AVANT la comparaison dans un `if()`.

```r
# ❌ INCORRECT
wilcox_signif <- (pvals <= alpha)
if (wilcox_signif != sign_signif) {  # ERREUR si NA!

# ✓ CORRECT
wilcox_signif <- if (is.na(pvals)) FALSE else (pvals <= alpha)
if (isTRUE(wilcox_signif != sign_signif)) {
```

### BP-018: Exclure NA de unique() pour comptage groupes
Utiliser `unique(g[!is.na(g)])` au lieu de `unique(g)` pour compter les
groupes réels. `unique()` inclut NA comme valeur unique.

```r
# ❌ INCORRECT
check_number <- length(unique(g))  # Compte NA comme un groupe!

# ✓ CORRECT
check_number <- length(unique(g[!is.na(g)]))
```

### BP-019: Condition de filtrage NA pour factors
La condition de filtrage des NA doit inclure les factors, pas seulement
les vectors (`is.vector(factor)` retourne FALSE).

```r
# ❌ INCORRECT
if (is.vector(x) && is.vector(g)) {

# ✓ CORRECT
if ((is.vector(x) || is.numeric(x)) && (is.vector(g) || is.factor(g))) {
```

### BP-020: Protection NULL avec isTRUE() dans %in%
`NULL %in% c("a","b")` retourne `logical(0)`, pas FALSE.

```r
# ❌ INCORRECT
!(chosen_test %in% c("med1way", "kruskal"))

# ✓ CORRECT
!(isTRUE(chosen_test %in% c("med1way", "kruskal")))
```

---

## 14.10 TITRE GRAPHIQUE

### BP-021: Titre dynamique selon test post-hoc
1. Identifier la première colonne contenant des lettres de groupement
2. Utiliser le nom de cette colonne comme titre
3. Ne PAS filtrer les colonnes contenant "mean" dans le nom (ex: "Bootstrap (mean)")

**Logique de scan**:
```r
# Sauter UNIQUEMENT les colonnes de statistiques (noms exacts)
if (tolower(cn) %in% c("categories", "category", "mean", "std", "se", "n", "sd")) next
```

**Fallback selon contexte**:
```r
if (n_groups_plot == 2) {
  plot_title <- if (isTRUE(check_normality)) "Student t-test" else "Wilcoxon"
} else {
  plot_title <- if (isTRUE(check_normality)) "ANOVA" else "Kruskal-Wallis"
}
```

---

## 14.11 TESTS NON-PARAMÉTRIQUES

### BP-022: Exécuter explicitement tous les tests
Chaque branche de l'arbre de décision DOIT exécuter explicitement son test:
- `chosen_test == "med1way"` → `med1way(x~g)$p.value`
- `chosen_test == "t1way"` → `t1way(x~g)$p.value`
- `chosen_test == "kruskal"` → `kruskal.test(x, g)$p.value`

### BP-023: Synchroniser pvals pour le retour
Après l'exécution des tests non-paramétriques, TOUJOURS synchroniser:
```r
pvals <- pvals3
```

### BP-024: Initialiser et propager chosen_test
1. Initialiser `chosen_test <- NULL` au début
2. L'assigner dans le diagnostic: `chosen_test <- recommended_test`
3. L'ajouter à `synth` avant le return

---

## 14.12 SYNCHRONISATION RETOURS

### BP-025: Synchroniser global_pvalue
Après l'appel à `.posthoc()`, synchroniser `global_pvalue` si manquant:
```r
if (!is.null(synth) && is.null(synth$global_pvalue)) {
  if (!is.null(synth$p.value)) {
    synth$global_pvalue <- synth$p.value
  }
}
```

### BP-026: Éviter duplication de paramètres
TOUJOURS vérifier qu'un paramètre n'apparaît qu'UNE SEULE FOIS dans un appel.

### BP-027: Passer x, g, id explicitement pour cas appariés
Quand `.multi_factor_analysis()` délègue à `.one_factor_analysis()` pour
2 conditions appariées, passer `x`, `g`, et `id` DIRECTEMENT.

### BP-028: Supprimer les print() de debug avant commit
TOUJOURS supprimer ou commenter les `print()` de debug avant commit.
Utiliser `.dbg()` à la place pour messages conditionnels.

================================================================================
15. CHECKLIST UNIFIÉE
================================================================================

Cette checklist remplace toutes les versions précédentes (v1, v2, v3).
À appliquer avant chaque commit impliquant messages utilisateur.

## ORTHOGRAPHE ET GRAMMAIRE (BP-002, BP-003)
□ Tous messages complets se terminent par un point ?
□ Orthographe "données" correcte (2 'n') ?
□ Accords pluriel/singulier cohérents ?
□ Accents français corrects ?
□ Terminologie statistique standard ?

## STRUCTURE DES ÉTAPES (BP-010, BP-011, BP-012)
□ Contrôles académiques avec préfixe "Contrôle ACADÉMIQUE" ?
□ Ajustement modèle annoncé avant contrôle résidus ?
□ Pas d'étapes redondantes entre appelant et fonction appelée ?
□ Séquence logique (ajustement → diagnostic) ?

## MESSAGES DIRECTIONNELS (BP-001)
□ Chaque changement de direction explicité ?
□ Cas "reste sur même direction" après re-contrôle explicité ?
□ Chaque anomalie détectée suivie d'un "-->" ?
□ Stratégie adoptée explicite ?
□ Cohérence avec décisions ultérieures ?

## LOGIQUE POST-HOCS (BP-013)
□ Post-hocs TOUJOURS effectués pour >2 groupes (philosophie KefiR) ?
□ Pas d'affichage inapproprié pour 2 groupes ?
□ Cohérence avec type d'analyse (ANCOVA, mixte, standard) ?

## PROTECTION NA (BP-017 à BP-020)
□ Comparaisons booléennes protégées avec isTRUE() ou !is.na() ?
□ Comptage groupes avec unique(g[!is.na(g)]) ?
□ Filtrage NA inclut factors et vectors ?
□ chosen_test protégé avec isTRUE() pour %in% ?

## OBJETS ET FORMAT (BP-006, BP-004, BP-007, BP-008)
□ `return=TRUE` retourne objet structuré ?
□ Énumérations ≥3 éléments avec puces `•` ?
□ Fonctions graphiques réinitialisent `par()` ?
□ Références bibliographiques en commentaires ?

## RECOMMANDATIONS (BP-005)
□ Actions/vérifications recommandées entre parenthèses ?
□ Tabulation appropriée ?

## TECHNIQUE (BP-014 à BP-016, BP-022 à BP-028)
□ do.call() avec as.name() pour noms de colonnes ?
□ paste0() par défaut pour messages ?
□ Tests non-paramétriques explicitement exécutés ?
□ pvals synchronisé avec pvals3 ?
□ global_pvalue synchronisé dans synth ?
□ Pas de print() de debug ?

================================================================================
16. HISTORIQUE DES MODIFICATIONS
================================================================================

Ce log chronologique documente l'évolution des bonnes pratiques.

---

### 2025-11-04 - Création initiale
- Sections 1-12 : Structure de base du guide
- Version 1.0

### 2025-01-19 - Section 13 ANCOVA
- Ajout section 13 : Ordre logique traitement ANCOVA
- Numérotation dynamique des assomptions
- Version 1.1

### 2025-11-24 - Session 18
- BP-001 (ex BP-009): Messages directionnels cohérents
- BP-006 (ex BP-010): Objets de retour complets
- BP-004 (ex BP-011): Format des listes à puces
- BP-007 (ex BP-012): Reset layout graphique
- BP-008 (ex BP-013): Références en commentaires
- Version 1.4

### 2025-11-25 - Session 19
- BP-001 étendu: Cas "reste sur même direction"
- BP-005 (ex BP-014): Recommandations entre parenthèses
- BP-002 (ex BP-015): Ponctuation messages finaux
- BP-009 (ex BP-016): Utiliser load_all_kefir()
- Version 1.5

### 2025-11-26 - Modification 12
- BP-002 fusionné (ex BP-015+BP-017): Ponctuation unifiée
- BP-003 (ex BP-018): Orthographe et accords
- BP-010 (ex BP-019): Format étapes contrôle
- BP-001 étendu (ex BP-020): Messages après anomalie
- BP-011 (ex BP-021): Annonce ajustement modèle
- BP-013 (ex BP-022): Post-hocs toujours effectués
- BP-014 (ex BP-023): do.call() avec as.name()
- BP-015 (ex BP-024): paste0() vs paste()
- BP-012 (ex BP-025): Éviter étapes redondantes
- BP-016 (ex BP-026): rstatix vs ezANOVA
- Version 1.7

### 2025-11-27 - Modification 12 (suite)
- Correction erreur ks.test
- Mise à jour documentation 6 fonctions
- Paramètre code= ajouté à .vbse()
- Version 1.8

### 2025-01-04 - Modification 14
- BP-022 (ex BP-031): Exécuter tests explicitement
- BP-023 (ex BP-032): Synchroniser pvals
- BP-024 (ex BP-033): Initialiser chosen_test
- Génération code pour tests non-paramétriques
- Version 2.0

### 2025-12-06 - Modification 15
- BP-025 (ex BP-035): Synchroniser global_pvalue
- BP-026 (ex BP-036): Éviter duplication paramètres
- BP-027 (ex BP-037): Passer x,g,id pour appariés
- BP-028 (ex BP-038): Supprimer print() debug
- Version 2.1

### 2026-02-08 - Correction NA
- BP-017 (ex BP-040): Protection NA avec isTRUE()
- BP-018 (ex BP-041): unique() sans NA
- BP-019 (ex BP-042): Filtrage NA pour factors
- BP-021 (ex BP-043): Titre dynamique graphique
- BP-020 (ex BP-044): Protection NULL avec isTRUE()
- **Restructuration complète du document**
- Version 2.0 (restructuré)

================================================================================
FIN DU GUIDE DES BONNES PRATIQUES
================================================================================
Version actuelle: 2.0 (restructuré)
Date: 2026-02-08
Prochaine révision: À chaque session majeure de développement
================================================================================
