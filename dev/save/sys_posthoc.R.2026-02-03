#' R\u00e9aliser diff\u00e9rents tests post-hoc en fonction du contexte statistique
#'
#' Cette fonction \code{.posthoc} r\u00e9alise un ensemble de tests post-hoc
#' (tests de Student, Wilcoxon, SNK, Dunn, etc.) en fonction :
#' \itemize{
#'   \item du nombre de groupes \u00e0 comparer (\code{number}) ;
#'   \item de la normalit\u00e9 pr\u00e9sum\u00e9e des donn\u00e9es (\code{normal}) ;
#'   \item de l'\u00e9galit\u00e9 pr\u00e9sum\u00e9e des variances (\code{var.equal}) ;
#'   \item du caract\u00e8re appari\u00e9 (\code{paired}) ;
#'   \item de la pr\u00e9sence \u00e9ventuelle d'un groupe de contr\u00f4le (\code{control}).
#' }
#'
#' Lorsque plusieurs groupes sont compar\u00e9s, la fonction applique les proc\u00e9dures
#' post-hoc adapt\u00e9es (par exemple, \code{\link[agricolae]{SNK.test}} pour SNK,
#' \code{\link[FSA]{dunnTest}} pour Dunn, \code{\link[DescTools]{DunnettTest}}
#' pour Dunnett, etc.). En cas d'options suppl\u00e9mentaires (\code{boot}, \code{conf},
#' \code{iter}), la fonction peut \u00e9galement r\u00e9aliser des tests bootstrap via
#' \code{.boots()} et des analyses de paires via \code{pairwise()} (fonctionnalit\u00e9s
#' internes ou fournies par des paquets tiers).
#'
#' @param x Num\u00e9rique. Le vecteur de donn\u00e9es \u00e0 analyser.
#' @param g Facteur ou vecteur cat\u00e9goriel. Indique \u00e0 quel groupe chaque valeur
#'   de \code{x} est associ\u00e9e.
#' @param alpha Num\u00e9rique. Seuil de signification (\emph{p-value}) pour tous
#'   les tests (par d\u00e9faut \code{0.05}).
#' @param normal Logique. \code{TRUE} si les donn\u00e9es sont suppos\u00e9es normales,
#'   \code{FALSE} sinon.
#' @param number Entier ou NULL. Nombre de groupes. Si NULL (d\u00e9faut), calcul\u00e9
#'   automatiquement via \code{length(unique(g))}.
#' @param var.equal Logique. \code{TRUE} si la variance est suppos\u00e9e homog\u00e8ne,
#'   \code{FALSE} sinon (par d\u00e9faut \code{FALSE}).
#' @param control Cha\u00eene de caract\u00e8res ou vecteur ou NULL. Nom(s) du(des)
#'   groupe(s) utilis\u00e9(s) comme contr\u00f4le(s). Si un contr\u00f4le est sp\u00e9cifi\u00e9,
#'   la fonction r\u00e9alise \u00e9galement un test de Dunnett
#'   (\code{\link[DescTools]{DunnettTest}}).
#' @param verbose Logique. \code{TRUE} (d\u00e9faut) pour afficher des messages de
#'   suivi, \code{FALSE} sinon.
#' @param debug Logique. \code{TRUE} pour afficher des messages de d\u00e9bogage
#'   d\u00e9taill\u00e9s, \code{FALSE} (d\u00e9faut) sinon.
#' @param code Logique. \code{TRUE} pour afficher des exemples de codes R
#'   \u00e9quivalents, \code{FALSE} (d\u00e9faut) sinon.
#' @param paired Logique. \code{TRUE} pour des donn\u00e9es appari\u00e9es, \code{FALSE}
#'   (d\u00e9faut) sinon. Certains tests (p. ex. Wilcoxon ou \code{t.test}) tiennent
#'   alors compte de cette information.
#' @param boot Logique. \code{TRUE} (d\u00e9faut) pour r\u00e9aliser des validations par
#'   bootstrap, \code{FALSE} sinon.
#' @param iter Entier. Nombre d'it\u00e9rations pour les proc\u00e9dures bootstrap
#'   (par d\u00e9faut \code{1/alpha * 10}).
#' @param conf Num\u00e9rique. Niveau de confiance pour les intervalles bootstrap
#'   (par d\u00e9faut \code{0.95}).
#' @param k Entier ou NULL. Compteur interne pour les messages (usage avanc\u00e9).
#'
#' @details
#' \strong{Strat\u00e9gie de s\u00e9lection des tests :}
#' \enumerate{
#'   \item \strong{Deux groupes seulement} (\code{number = 2}):
#'   \itemize{
#'     \item Si \code{normal = TRUE} : \code{t.test} (Student ou Welch selon
#'       \code{var.equal})
#'     \item Si \code{normal = FALSE} : \code{wilcox.test} (Wilcoxon-Mann-Whitney
#'       ou Wilcoxon appari\u00e9)
#'     \item Pour donn\u00e9es appari\u00e9es non normales : ajout du test de signe si
#'       asym\u00e9trie d\u00e9tect\u00e9e (test MGG)
#'   }
#'   \item \strong{Plus de deux groupes} (\code{number > 2}):
#'   \itemize{
#'     \item Si \code{normal = TRUE} et \code{var.equal = TRUE} :
#'       \code{pairwise.t.test} avec pool.sd=TRUE, plus tests SNK, Tukey,
#'       Scheff\u00e9, Waller-Duncan
#'     \item Si \code{normal = TRUE} et \code{var.equal = FALSE} :
#'       \code{pairwise.t.test} avec pool.sd=FALSE, plus Games-Howell et Dunnett T3
#'     \item Si \code{normal = FALSE} : \code{pairwise.wilcox.test}, test de Dunn,
#'       et test de Brunner-Munzel si distributions diff\u00e9rentes d\u00e9tect\u00e9es (test KS)
#'     \item Pour donn\u00e9es appari\u00e9es non normales : ajout du test de Nemenyi
#'     \item Si valeurs extr\u00eames d\u00e9tect\u00e9es : ajout du test Lincon sur donn\u00e9es
#'       tronqu\u00e9es
#'   }
#' }
#'
#' \strong{Validation de la fiabilit\u00e9 des tests :}
#' \itemize{
#'   \item Pour Wilcoxon non appari\u00e9 : test de Kolmogorov-Smirnov (avec correction
#'     de Sidak) pour v\u00e9rifier l'identit\u00e9 des distributions
#'   \item Pour Wilcoxon appari\u00e9 : test MGG (Miao-Gel-Gastwirth) pour v\u00e9rifier
#'     la sym\u00e9trie des diff\u00e9rences
#'   \item Si conditions non remplies : ajout automatique de tests alternatifs
#'     robustes (Brunner-Munzel, test de signe)
#' }
#'
#' Dans tous les cas, si un contr\u00f4le est sp\u00e9cifi\u00e9 (\code{control}), la fonction
#' effectue \u00e9galement un test de Dunnett (\code{\link[DescTools]{DunnettTest}})
#' afin de comparer ce contr\u00f4le \u00e0 chacun des autres groupes.
#'
#' Par ailleurs, si l'option \code{boot = TRUE}, la fonction ex\u00e9cute des
#' comparaisons par bootstrap via \code{.boots()}, et peut ainsi v\u00e9rifier la
#' robustesse des tests classiques (en affichant des warnings si le bootstrap
#' d\u00e9tecte des incoh\u00e9rences).
#'
#' @return
#' \code{.posthoc} renvoie un objet de classe \code{"posthoc"}, une liste
#' contenant g\u00e9n\u00e9ralement :
#' \itemize{
#'   \item \code{groups} : un data.frame indiquant la cat\u00e9gorisation de chaque
#'     groupe selon la comparaison (lettres pour les groupes \u00e9quivalents, \u00e9toiles
#'     pour les comparaisons au contr\u00f4le, etc.) ;
#'   \item \code{p.value} : la ou les p-values associ\u00e9es aux tests effectu\u00e9s
#'     (valeur unique pour 2 groupes, matrice pour >2 groupes) ;
#'   \item \code{bootstrap} : (optionnel) les r\u00e9sultats des comparaisons par
#'     bootstrap, si \code{boot = TRUE}.
#' }
#' Des \u00e9l\u00e9ments suppl\u00e9mentaires peuvent \u00eatre ajout\u00e9s selon le test post-hoc r\u00e9alis\u00e9
#' (p. ex. \code{Dunnett}, \code{SNK}, \code{Wilcoxon_holm}, etc.).
#'
#' @references
#' \itemize{
#'   \item Lehmann, E. L., & Romano, J. P. (2005). \emph{Testing Statistical
#'     Hypotheses} (3\u1d49 \u00e9d.). Springer. (test de signe, Wilcoxon)
#'   \item Zheng, T., & Gastwirth, J. L. (2010). On bootstrap tests of symmetry
#'     about an unknown median. \emph{Journal of Data Science}, 8(3), 397\u2013412.
#'     (test MGG)
#'   \item Brunner, E., & Munzel, U. (2000). The nonparametric Behrens-Fisher
#'     problem: Asymptotic theory and a small-sample approximation.
#'     \emph{Biometrical Journal}, 42(1), 17-25. (test de Brunner-Munzel)
#' }
#'
#' @importFrom DescTools DunnettTest
#' @importFrom agricolae SNK.test HSD.test scheffe.test waller.test
#' @importFrom FSA dunnTest
#' @importFrom WRS2 lincon
#' @importFrom stringr str_split_fixed
#' @importFrom rstatix games_howell_test identify_outliers
#' @importFrom PMCMRplus dunnettT3Test frdAllPairsNemenyiTest
#' @importFrom stats t.test wilcox.test aov pairwise.t.test pairwise.wilcox.test
#'   quantile median sd binom.test
#'
#' @seealso
#' \itemize{
#'   \item \code{\link{t.test}}, \code{\link{wilcox.test}} pour les tests de base,
#'   \item \code{\link[agricolae]{SNK.test}} pour le test de Newman-Keuls,
#'   \item \code{\link[FSA]{dunnTest}} pour le test de Dunn,
#'   \item \code{\link[DescTools]{DunnettTest}} pour le test de Dunnett,
#'   \item \code{\link[WRS2]{lincon}} pour les m\u00e9thodes robustes (lin\u00e9aires),
#'   \item \code{\link[rstatix]{games_howell_test}} pour le test de Games-Howell,
#'   \item \code{.boots()}, \code{pairwise()}, \code{catego()} (fonctions internes)
#'     pour la gestion du bootstrap et des comparaisons multiples.
#' }
#'
#' @examples
#' \dontrun{
#' # Exemple minimal (2 groupes, donn\u00e9es normales, variances \u00e9gales)
#' set.seed(123)
#' x <- rnorm(30)
#' g <- factor(rep(c("GroupeA", "GroupeB"), each = 15))
#' res <- .posthoc(x, g, alpha = 0.05, normal = TRUE, var.equal = TRUE)
#' print(res)
#'
#' # Exemple avec plus de 2 groupes et donn\u00e9es non normales
#' set.seed(123)
#' x2 <- runif(40)
#' g2 <- factor(rep(c("G1", "G2", "G3", "G4"), each = 10))
#' res2 <- .posthoc(x2, g2, alpha = 0.01, normal = FALSE, var.equal = FALSE)
#' print(res2)
#'
#' # Exemple avec groupe contr\u00f4le
#' set.seed(456)
#' x3 <- c(rnorm(10, 0), rnorm(10, 1), rnorm(10, 0.5))
#' g3 <- factor(rep(c("Control", "TreatA", "TreatB"), each = 10))
#' res3 <- .posthoc(x3, g3, alpha = 0.05, normal = TRUE,
#'                  var.equal = TRUE, control = "Control")
#' print(res3)
#' }
#'
#' @keywords internal
#' @export
.posthoc <- function(
    x, g,
    alpha = 0.05,
    normal = TRUE,
    number = NULL,
    var.equal = FALSE,
    control = NULL,
    verbose = TRUE,
    debug = FALSE,
    code = FALSE,
    paired = FALSE,
    boot = TRUE,
    boot_type = NULL,  # NULL: auto, "mean", "median", or "meanbp"
    iter = 1/alpha*10,
    conf = 0.95,
    k = NULL,
    chosen_test = NULL
) {
  # -- Coercitions --
  if (is.data.frame(x)) x <- x[[1]]
  if (is.matrix(x)) x <- x[, 1, drop = TRUE]
  if (is.list(x)) x <- unlist(x, use.names = FALSE)
  x <- as.vector(x)
  if (!is.numeric(x)) stop(".posthoc() attend un vecteur num\u00e9rique 'x'.")

  if (is.data.frame(g)) g <- g[[1]]
  if (is.matrix(g)) g <- g[, 1, drop = TRUE]
  if (is.list(g)) g <- unlist(g, use.names = FALSE)
  g <- droplevels(factor(g))
  lev <- levels(g)
  ng <- length(lev)

  if (is.null(number)) number <- ng

  if (length(x) != length(g)) stop("Longueurs incompatibles entre x et g.")

  if (ng < 2L || number < 2L) {
    synth <- list(
      groups = data.frame(categories = lev),
      note = "Pas assez de cat\u00e9gories (number < 2) pour r\u00e9aliser des post-hoc."
    )
    class(synth) <- "posthoc"
    .dbg(NULL, "Fin de .posthoc() - moins de 2 groupes.",
         debug = debug)
    return(synth)
  }

  g1 <- lev[1L]
  g2 <- lev[2L]

  if (normal == TRUE) {
    .dbg(".posthoc() - Post-hoc on normal data.",
         ".posthoc() - Post-hoc sur donn\u00e9es normales.",
         debug = debug)

    if (number == 2) {
      if (var.equal == TRUE) {
        ########################
        #  STUDENT (var.equal = TRUE)
        ########################
        if (isTRUE(code)) {
          cat("# Test de Student\n",
              "levels_g <- levels(factor(g))\n",
              "t.test(x[g==levels_g[1]], x[g==levels_g[2]], var.equal = TRUE, paired = ", paired, ")\n", sep = "")
        }

        # CONTR\u00d4LE CRITIQUE : V\u00e9rifier si r\u00e9plicats pr\u00e9sents (multiples obs par niveau)
        # R\u00e9f\u00e9rence: Maxwell et al. (2018), pp. 597-599 - Repeated measures with multiple obs per cell
        n_g1 <- sum(g == g1)
        n_g2 <- sum(g == g2)

        if (isTRUE(paired) && n_g1 != n_g2) {
          .exit(
            paste0("ERROR: Paired t-test requested but unequal sample sizes (n1=", n_g1, ", n2=", n_g2, ").\n",
                   "\tPaired design requires equal n per condition."),
            paste0("ERREUR : t-test appari\u00e9 demand\u00e9 mais tailles d'\u00e9chantillon in\u00e9gales (n1=", n_g1, ", n2=", n_g2, ").\n",
                   "\tPlan appari\u00e9 n\u00e9cessite n \u00e9gal par condition."),
            verbose = verbose, code = code, return = TRUE
          )
        }

        # NOTE: La v\u00e9rification de r\u00e9plicats a \u00e9t\u00e9 supprim\u00e9e ici car:
        # 1. Pour donn\u00e9es appari\u00e9es, .one_factor_analysis() a d\u00e9j\u00e0 v\u00e9rifi\u00e9 la structure via .align_pairs()
        # 2. L'ancienne heuristique (bas\u00e9e sur divisibilit\u00e9 de n) donnait des faux positifs
        #    (ex: 20 sujets \u00d7 2 conditions = 20 obs/niveau, divisible par 2, 4, 5 -> faux positif)
        # 3. Si on arrive ici avec paired=TRUE, les donn\u00e9es ont \u00e9t\u00e9 align\u00e9es correctement

        pvals <- t.test(x[g == g1], x[g == g2], var.equal = TRUE, paired = paired)$p.value
        control_chr <- if (is.null(control)) NULL else as.character(control)[1]
        ind_control <- if (is.null(control_chr)) integer(0L) else match(control_chr, lev)

        if (isTRUE(paired)) {
          # --- CAS APPARI\u00c9 : PAS de bootstrap "indice moyenne"
          k <- .vbse(
            "Post-hoc comparison of the two paired levels using a paired Student's t-test [t.test(paired = TRUE)].",
            "Comparaison post-hoc des 2 niveaux appari\u00e9s par un test de Student [t.test(paired == TRUE)].",
            verbose = verbose, code = code, k = k, cpt = "on"
          )

          # R\u00e9sultat (significatif / non significatif)
          if (pvals <= alpha) {
            k <- .vbse(
              paste0("Significant difference between the paired levels (p = ", .format_pval(pvals), ")."),
              paste0("Diff\u00e9rence significative entre les niveaux appari\u00e9s (p = ", .format_pval(pvals), ")."),
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          } else {
            k <- .vbse(
              paste0("No significant difference between the paired levels (p = ", .format_pval(pvals), ")."),
              paste0("Aucune diff\u00e9rence significative entre les niveaux appari\u00e9s (p = ", .format_pval(pvals), ")."),
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          }

          synth <- list()
          if (length(ind_control) != 1L) {
            # Sans t\u00e9moin : lettres a/b selon la significativit\u00e9
            synth$groups <- data.frame(
              categories = lev,
              Student_Holm = if (pvals <= alpha) c("a", "b") else c("a", "a")
            )
          } else {
            # Avec t\u00e9moin : \u00e9toiles sur la cat\u00e9gorie non t\u00e9moin
            stars <- c("", "")
            stars[-ind_control] <- ifelse(pvals <= 0.001, "***",
                                          ifelse(pvals <= 0.01,  "**",
                                                 ifelse(pvals <= 0.05,   "*", "")))
            synth$groups <- data.frame(
              categories = lev,
              Student_Holm = stars
            )
          }
          synth$p.value <- pvals

          # On peut garder le bootstrap "robustesse du Student" (optionnel) :
          if (isTRUE(boot)) {
            synth$bootstrap <- .boots(
              x, g,
              ctrl = (length(ind_control) == 1L),
              type = "mean",
              var.equal = TRUE,
              conf = conf, iter = iter, alpha = alpha,
              paired = TRUE, control = control
            )
            colnames(synth$bootstrap$groups)[2] <- "Student_bootstrapped"
          }

        } else {

          k <- .vbse(
            "a) Analysis of mean differences by bootstrap [pairwise.boot() from {KefiR}].",
            "a) Analyse des diff\u00e9rences de moyennes par bootstrap [pairwise.boot() de {KefiR}]",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          # Utiliser boot_type sp\u00e9cifi\u00e9 ou la logique automatique
          final_boot_type <- if (!is.null(boot_type)) boot_type else "mean"
          synth2 <- pairwise(x, g, type = "boot", alpha = alpha, control = control, boot = FALSE,
                             boot_type = final_boot_type, conf = conf, iter = iter, debug = debug)

          if (length(ind_control) != 1) {
            ########################
            #	Pas de control
            ########################
            # b) Student
            k <- .vbse(
              "b) Student test [t.test()].",
              "b) Test de Student [t.test()]",
              verbose = verbose, code = code, k = k, cpt = "off"
            )

            synth <- list()
            if (pvals <= alpha) {
              synth$groups <- data.frame(categories = lev, Student = c("a", "b"))
            } else {
              synth$groups <- data.frame(categories = lev, Student = c("a", "a"))
            }

            synth$p.value <- pvals

          } else {
            #######################
            #	control
            ########################
            .dbg(".posthoc() - Student with control.",
                 ".posthoc() - Student avec pr\u00e9sence d'un T\u00e9moin.",
                 debug = debug, verbose = verbose)

            k <- .vbse(
              "b) Student test [t.test()] with control.",
              "b) Test de Student [t.test()] avec t\u00e9moin.",
              verbose = verbose, code = code, k = k, cpt = "off"
            )

            synth <- list()
            stars <- c("", "")
            stars[-ind_control] <- ifelse(pvals <= 0.001, "***",
                                          ifelse(pvals <= 0.01, "**",
                                                 ifelse(pvals <= 0.05, "*", "")))
            synth$groups <- data.frame(categories = lev, Student = stars)
            synth$p.value <- pvals
          }

          # Bootstrap sur le test de Student
          if (boot == TRUE) {
            synth$bootstrap <- .boots(
              x, g,
              ctrl = (length(ind_control) == 1),
              type = "mean", var.equal = TRUE,
              conf = conf, iter = iter,
              alpha = alpha, paired = paired, control = control
            )
            colnames(synth$bootstrap$groups)[2] <- "Student_bootstrapped"
          }

          # Ajout du bootstrap sur la moyenne
          ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
          synth$groups <- data.frame(
            "categories" = synth$groups[, 1],
            "Bootstrap" = synth2$groups[ind_temp, 2],
            "Student_Holm" = synth$groups[, 2]
          )

          # V\u00e9rification bootstrap APR\u00c8S cr\u00e9ation des 3 colonnes
          if (isTRUE(verbose) && isTRUE(boot) && !is.null(synth$bootstrap) &&
              ncol(synth$groups) >= 3 && any(synth$bootstrap$groups[, 2] != synth$groups[, 3])) {
            ang <- "Warning! Bootstrap detects weaknesses in the significance of the results."
            fr <- "Attention ! Le bootstrap d\u00e9tecte des faiblesses dans la signification des r\u00e9sultats."
            k <- .vbse(ang, fr, verbose = verbose, code = code, k = k, cpt = "off")
          }
        }

        ########################
        #	STUDENT var.equal=FALSE - Test t de Welch
        ########################
      } else if (var.equal == FALSE) {
        if (isTRUE(code)) {
          cat("# Test t de Welch\nt.test(x[g==unique(g)[1]],x[g==unique(g)[2]],var.equal=FALSE, paired=", paired, ")\n")
        }

        pvals <- t.test(x[g == g1], x[g == g2], var.equal = FALSE, paired = paired)$p.value
        control_chr <- if (is.null(control)) NULL else as.character(control)[1]
        ind_control <- if (is.null(control_chr)) integer(0L) else match(control_chr, lev)

        # a) Bootstrap sur l'indice moyen
        k <- .vbse(
          "a) Posthoc - Analysis of mean differences by bootstrap [pairwise.boot(mu='mean') from {KefiR}].",
          "a) Posthoc - Analyse des diff\u00e9rences de moyennes par bootstrap [pairwise.boot(mu='mean') de {KefiR}]",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        # Utiliser boot_type sp\u00e9cifi\u00e9 ou la logique automatique
        final_boot_type <- if (!is.null(boot_type)) boot_type else "mean"
        synth2 <- pairwise(x, g, type = "boot", alpha = alpha, control = control, boot = FALSE,
                           boot_type = final_boot_type, conf = conf, iter = iter, debug = debug)

        if (length(ind_control) != 1) {
          ########################
          #	Pas de control
          ########################
          # b) Student
          k <- .vbse(
            "b) Student test [t.test(var.equal=FALSE)].",
            "b) Test de Student \u00e0 variances in\u00e9gales [t.test(var.equal=FALSE)]",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          synth <- list()
          if (pvals <= alpha) {
            synth$groups <- data.frame(categories = lev, Student = c("a", "b"))
          } else {
            synth$groups <- data.frame(categories = lev, Student = c("a", "a"))
          }

          synth$p.value <- pvals

          if (boot == TRUE) {
            synth$bootstrap <- .boots(
              x, g, ctrl = FALSE,
              type = "mean", var.equal = FALSE, conf = conf, iter = iter, alpha = alpha,
              paired = paired, control = control
            )
            colnames(synth$bootstrap$groups)[2] <- "Student_bootstrapped"
          }

          # Ajout du bootstrap sur la moyenne - AVANT la v\u00e9rification bootstrap
          ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
          synth$groups <- data.frame(
            "categories" = synth$groups[, 1],
            "Bootstrap" = synth2$groups[ind_temp, 2],
            "Student_Holm" = synth$groups[, 2]
          )

          # V\u00e9rification bootstrap APR\u00c8S cr\u00e9ation des 3 colonnes
          if ((verbose == TRUE) && (boot == TRUE) && !is.null(synth$bootstrap) &&
              ncol(synth$groups) >= 3 && any(synth$bootstrap$groups[, 2] != synth$groups[, 3])) {
            ang <- "Warning! Bootstrap detects weaknesses in the significance of the results."
            fr <- "Attention ! Le bootstrap d\u00e9tecte des faiblesses dans la signification des r\u00e9sultats."
            k <- .vbse(ang, fr, verbose = verbose, code = code, k = k, cpt = "off")
          }

        } else {
          ########################
          #	control
          ########################
          k <- .vbse(
            "b) Student test [t.test(var.equal=FALSE)] with control.",
            "b) Test de Student \u00e0 variances in\u00e9gales [t.test(var.equal=FALSE)] avec t\u00e9moin.",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          synth <- list()
          stars <- c("", "")
          stars[-ind_control] <- ifelse(pvals <= 0.001, "***",
                                        ifelse(pvals <= 0.01, "**",
                                               ifelse(pvals <= 0.05, "*", "")))
          synth$groups <- data.frame(categories = lev, Student = stars)
          synth$p.value <- pvals

          ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
          synth$groups <- data.frame(
            "categories" = synth$groups[, 1],
            "Bootstrap" = synth2$groups[ind_temp, 2],
            "Student_Holm" = synth$groups[, 2]
          )

          if (boot == TRUE) {
            synth$bootstrap <- .boots(
              x, g, ctrl = TRUE,
              type = "mean", var.equal = FALSE, conf = conf, iter = iter, alpha = alpha,
              paired = paired, control = control
            )
            colnames(synth$bootstrap$groups)[2] <- "Student_bootstrapped"
          }

          # V\u00e9rification bootstrap avec contr\u00f4les de s\u00e9curit\u00e9
          if ((verbose == TRUE) && (boot == TRUE) && !is.null(synth$bootstrap) &&
              ncol(synth$groups) >= 3 && any(synth$bootstrap$groups[, 2] != synth$groups[, 3])) {
            ang <- "Warning! Bootstrap detects weaknesses in the significance of the results."
            fr <- "Attention ! Le bootstrap d\u00e9tecte des faiblesses dans la signification des r\u00e9sultats."
            k <- .vbse(ang, fr, verbose = verbose, code = code, k = k, cpt = "off")
          }
        }
      }

    } else if (number > 2) {
      .dbg(NULL, ".posthoc() - '>2 cat\u00e9gories'.",
           debug = debug)

      if (paired) {
        k <- .vbse(
          "Posthoc - Post-hoc tests on paired normal groups.",
          "Posthoc - Tests post-hoc sur groupes normaux appari\u00e9s.",
          verbose = verbose, code = code, k = k
        )
      } else {
        k <- .vbse(
          "Posthoc - Post-hoc tests on normal groups.",
          "Posthoc - Tests post-hoc sur groupes normaux.",
          verbose = verbose, code = code, k = k
        )
      }

      # Code: Titre posthocs
      if (isTRUE(code)) {
        cat("# 10) Tests post-hoc\n\n")
      }

      ################
      # a) Bootstrap sur l'indice moyen
      k <- .vbse(
        "a) Posthoc - Analysis of mean differences by bootstrap [pairwise.boot() from {KefiR}].",
        "a) Posthoc - Analyse des diff\u00e9rences de moyennes par bootstrap [pairwise.boot() de {KefiR}].",
        verbose = verbose, code = code, k = k, cpt = "off"
      )

      # Utiliser boot_type sp\u00e9cifi\u00e9 ou la logique automatique
      final_boot_type <- if (!is.null(boot_type)) boot_type else "mean"
      synth2 <- pairwise(x, g, type = "boot", alpha = alpha, control = control, boot = FALSE,
                         boot_type = final_boot_type, conf = conf, iter = iter, debug = debug)

      ################
      # b) R\u00e9aliser un test de Student en pairwise en tenant compte du sd.pool.
      if (paired == TRUE) {
        if (isTRUE(code)) {
          cat("# Tests t appari\u00e9s\nresult <- pairwise.t.test(x,g,paired=TRUE)\n# Identification des groupes\ncatego(result)\n")
        }

        k <- .vbse(
          "b) Posthoc - Student test [pairwise.t.test(paired=TRUE)].",
          "b) Posthoc - Test de Student [pairwise.t.test(paired=TRUE)].",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        synth <- pairwise(x, g, type = "mean", pool.sd = FALSE, alpha = alpha, control = control, boot = boot,
                          conf = conf, iter = iter, paired = paired)

      } else if (paired == FALSE) {
        if (var.equal == FALSE) {
          if (isTRUE(code)) {
            cat("# Tests t appari\u00e9s\nresult <- pairwise.t.test(x,g,pool.sd=FALSE)\n# Identification des groupes\ncatego(result)\n")
          }

          k <- .vbse(
            "b) Posthoc - Student test [pairwise.t.test(pool.sd=FALSE)].",
            "b) Posthoc - Test de Student [pairwise.t.test(pool.sd=FALSE)].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          synth <- pairwise(x, g, type = "mean", pool.sd = FALSE, alpha = alpha, control = control, boot = boot,
                            conf = conf, iter = iter, paired = paired)

        } else if (var.equal == TRUE) {
          if (isTRUE(code)) {
            cat("# Tests t appari\u00e9s\nresult <- pairwise.t.test(x,g,pool.sd=TRUE)\n# Identification des groupes\ncatego(result)\n")
          }

          ang <- "b) Posthoc - Student test [pairwise.t.test(pool.sd=TRUE)]."
          fr <- "b) Posthoc - Test de Student [pairwise.t.test(pool.sd=TRUE)]."
          k <- .vbse(ang, fr, verbose = verbose, code = code, k = k, cpt = "off")

          synth <- pairwise(x, g, type = "mean", pool.sd = TRUE, alpha = alpha, control = control, boot = boot,
                            conf = conf, iter = iter, paired = paired)
        }
      }

      colnames(synth$groups)[2] <- "Student_Holm"

      # Agglom\u00e9rat du bootstrap median bootstrap sur colonne 2, ...
      ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
      synth$groups <- data.frame(
        "categories" = synth$groups[, 1],
        "Bootstrap" = synth2$groups[ind_temp, 2],
        "Student_Holm" = synth$groups[, 2]
      )

      # Plus bootstrap int\u00e9gr\u00e9
      if (boot == TRUE) {
        if (any(synth$bootstrap$groups[, 2] != synth$groups[, 3])) {
          k <- .vbse(
            "\tWarning! Bootstrap detects weaknesses in the significance of the results.",
            "\tAttention ! Le bootstrap d\u00e9tecte des faiblesses dans la signification des r\u00e9sultats.",
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        }
        colnames(synth$bootstrap$groups)[2] <- "Student_Holm_bootstrapped"
      }

      if ((var.equal == TRUE & length(control) == 0 & paired == FALSE)) {
        # Tests Scheff\u00e9, Tukey, SNK, Waller-Duncan n\u00e9cessitent agricolae
        if (requireNamespace("agricolae", quietly = TRUE)) {
          ################
          # c) Test de Scheff\u00e9
          if (isTRUE(code)) {
            cat("#Test de Scheff\u00e9\nagricolae::scheffe.test(myaov,'g',alpha=", alpha, ")")
          }

          k <- .vbse(
            "c) Posthoc - Conservative Scheff\u00e9 test [scheffe.test() of {agricolae}].",
            "c) Posthoc - Test conservateur de Scheff\u00e9 [scheffe.test() of {agricolae}].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          formula <- formula(x ~ g)
          data <- data.frame(x, g)
          data$g <- factor(data$g)
          mya <- suppressWarnings(aov(formula = formula, data = data))
          myscheffe <- agricolae::scheffe.test(mya, "g", alpha = alpha)

          ind_temp <- match(synth$groups[, 1], rownames(myscheffe$groups))
          synth$groups <- data.frame(synth$groups, "Scheffe" = myscheffe$groups$groups[ind_temp])

          ################
          # d) Test de Tukey
          if (isTRUE(code)) {
            cat("#Test de Tukey\nagricolae::HSD.test(myaov,'g',alpha=", alpha, ")")
          }

          k <- .vbse(
            "d) Posthoc - Conservative Tukey test [HSD.test() of {agricolae}].",
            "d) Posthoc - Test conservateur de Tukey [HSD.test() of {agricolae}].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          mytukey <- agricolae::HSD.test(mya, "g", alpha = alpha)

          ind_temp <- match(synth$groups[, 1], rownames(mytukey$groups))
          synth$groups <- data.frame(synth$groups, "Tukey" = mytukey$groups$groups[ind_temp])

          ################
          # e) Test de Newman-Keuls
          if (isTRUE(code)) {
            cat("#Test de Newman-Keuls\nagricolae::SNK.test(myaov,'g',alpha=", alpha, ")")
          }

          k <- .vbse(
            "e) Posthoc - Powerful Newman-Keuls test [SNK.test() of {agricolae}].",
            "e) Posthoc - Test puissant de Newman-Keuls [SNK.test() of {agricolae}].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          mynk <- agricolae::SNK.test(mya, "g", alpha = alpha)

          ind_temp <- match(synth$groups[, 1], rownames(mynk$groups))
          synth$groups <- data.frame(synth$groups, "SNK" = mynk$groups$groups[ind_temp])

          cat1 <- unique(unlist(strsplit(synth$groups[, 3], "")))
          cat2 <- unique(unlist(strsplit(mynk$groups$groups, "")))
          rownames(synth$groups) <- rep(c(), nrow(synth$groups))

          control_chr <- if (is.null(control)) NULL else as.character(control)[1]
          ind_control <- if (is.null(control_chr)) integer(0L) else match(control_chr, lev)

          if ((length(cat1) != length(cat2)) & (length(ind_control) != 1)) {
            k <- .vbse(
              "Warning! pairwise.t.test() and SNK.test() don't return the same number of groups.",
              "Attention ! pairwise.t.test() et SNK.test() ne renvoient pas le m\u00eame nombre de groupes.",
              k = k, cpt = "off"
            )
          }

          ################
          # f) Test de Waller-Duncan
          mywd <- tryCatch(agricolae::waller.test(mya, "g"), error = function(e) NULL)
          if (!is.null(mywd)) {
            if (isTRUE(code)) {
              cat("#Test de Waller-Duncan\nagricolae::waller.test(myaov,'g')\n")
            }

            k <- .vbse(
              "f) Posthoc - Powerful Waller-Duncan test [waller.test() of {agricolae}].",
              "f) Posthoc - Test puissant de Waller-Duncan [waller.test() of {agricolae}].",
              verbose = verbose, code = code, k = k, cpt = "off"
            )

            ind_temp <- match(synth$groups[, 1], rownames(mywd$groups))
            synth$groups <- data.frame(synth$groups, "Waller-Duncan" = mywd$groups$groups[ind_temp])
          }
        } else {
          # agricolae non disponible - informer l'utilisateur
          k <- .vbse(
            "Note: Additional post-hoc tests (Scheffe, Tukey, SNK, Waller-Duncan) require {agricolae} package.",
            "Note : Les tests post-hoc suppl\u00e9mentaires (Scheff\u00e9, Tukey, SNK, Waller-Duncan) n\u00e9cessitent le package {agricolae}.",
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        }

      } else if ((var.equal == TRUE) & (length(control) > 0) & (paired == FALSE)) {
        if (requireNamespace("DescTools", quietly = TRUE)) {
          if (isTRUE(code)) {
            cat("# Test de Dunnett car pr\u00e9sence de T\u00e9moin\nlibrary(DescTools)\nDunnettTest(x,g,control='", control, "')\n")
          }

          k <- .vbse(
            "c) Posthoc - See also post-hoc Dunnett test for the control [DunnettTest() from {DescTools}].",
            "c) Posthoc - Voir aussi le test post-hoc de Dunnett pour le contr\u00f4le [DunnettTest() de {DescTools}].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          p_value_to_symbol <- function(p_value) {
            if (p_value < 0.001) {
              return("***")
            } else if (p_value < 0.01) {
              return("**")
            } else if (p_value < 0.05) {
              return("*")
            } else {
              return("")
            }
          }

          dunnett_results <- DescTools::DunnettTest(x, g, control = control)
          dunnett_results$Significance <- sapply(dunnett_results[[1]][, 4], p_value_to_symbol)
          decoupage <- str_split_fixed(names(dunnett_results$Significance), "-", 2)

          if (length(unique(decoupage[, 2])) == 1) {
            categories <- c(decoupage[, 1], unique(decoupage[, 2]))
            lettre <- c(dunnett_results$Significance, "")
          } else {
            .exit(
              "Le traitement de la sortie DunnettTest() renvoie une erreur. SVP, lancez .posthoc() avec l'argument debug = TRUE.",
              verbose = verbose
            )
          }

          lettre <- lettre[match(synth$groups$categories, categories)]
          synth$groups <- cbind(synth$groups, "Dunnett" = lettre)
          rownames(synth$groups) <- NULL
        }
      } else if ((var.equal == FALSE) & (paired == FALSE)) {
        ################
        # c) Test de Games-Howell
        if (isTRUE(code)) {
          cat("#Test de Games-Howell\nlibrary(rstatix)\ngames_howell_test(x~g, data=data)\n")
        }

        k <- .vbse(
          "c) Posthoc - Games-Howell test on normally distributed data with non-homogeneous variances [games_howell_test() of {rstatix}].",
          "c) Posthoc - Test de Games-Howell sur donn\u00e9es normales \u00e0 variances non-homog\u00e8nes...\n\t\t... [games_howell_test() of {rstatix}].",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        dt <- data.frame("x" = x, "g" = g)
        resultGH <- games_howell_test(x ~ g, data = dt)

        # Extraire les noms des classes uniques
        group_names <- unique(c(resultGH$group1, resultGH$group2))

        # Initialiser une matrice de NA avec les noms des groupes comme lignes et colonnes
        p_value_matrix <- matrix(NA, nrow = length(group_names), ncol = length(group_names),
                                 dimnames = list(group_names, group_names))

        # Remplir la matrice avec les p-values
        for (i in seq_len(nrow(resultGH))) {
          group1 <- resultGH$group1[i]
          group2 <- resultGH$group2[i]
          p_value <- resultGH$p.adj[i]
          p_value_matrix[group1, group2] <- p_value
          p_value_matrix[group2, group1] <- p_value  # La matrice est sym\u00e9trique
        }

        p_value_matrix <- p_value_matrix[-1, -ncol(p_value_matrix)]

        # Afficher la matrice de p-values
        a <- list()
        a$p.value <- p_value_matrix
        synthGamesHowell <- catego(a)

        lettre <- synthGamesHowell$groups[, 2]
        lettre <- lettre[match(synth$groups$categories, synthGamesHowell$groups[, 1])]
        synth$groups <- cbind(synth$groups, "Games-Howell" = lettre)
        rownames(synth$groups) <- NULL

        ################
        # d) Test de Dunnett T3
        if (requireNamespace("PMCMRplus", quietly = TRUE)) {
          if (isTRUE(code)) {
            cat("#Test de Dunnett T3\nlibrary(PMCMRplus)\nresult <-dunnettT3Test(myaov)\nKefiR\ncatego(result)\n")
          }

          k <- .vbse(
            "d) Posthoc - Dunnett T3 test on normally distributed data with non-homogeneous variances [dunnettT3Test() of {PMCMRplus}].",
            "d) Posthoc - Test de Dunnett T3 sur donn\u00e9es normales \u00e0 variances non-homog\u00e8nes [dunnettT3Test() of {PMCMRplus}].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          formula <- formula(x ~ g)
          data <- data.frame(x, g)
          data$g <- factor(data$g)
          mya <- suppressWarnings(aov(formula = formula, data = data))
          DunnettT3 <- catego(PMCMRplus::dunnettT3Test(mya))

          lettre <- DunnettT3$groups[, 2]
          lettre <- lettre[match(synth$groups$categories, DunnettT3$groups[, 1])]
          synth$groups <- cbind(synth$groups, "Dunnett T3" = lettre)
          rownames(synth$groups) <- NULL
        }
      }
    }

  } else if (normal == FALSE) {
    #================================================
    #   Non-param\u00e9trique
    #================================================
    .dbg(NULL, "post-hoc sur donn\u00e9es non normales - k==2 et k>2.",
         debug = debug)

    check_wilcox_fiability <- TRUE

    if (paired == FALSE) {
      #------------------------------------------
      # Contr\u00f4le de la distribution pour \u00e9valuer la fiabilit\u00e9 du test de Wilcoxon-Mann-Witney...
      #------------------------------------------
      # Centrer sur la m\u00e9diane pour fiabilis\u00e9 le contr\u00f4le des \u00e9quivalences de distributions par KS
      sd_cr <- by(x, g, stats::sd, na.rm = T)
      median_cr <- by(x, g, stats::median, na.rm = T)
      data_cr <- x
      for (i in names(median_cr)) {
        data_cr[g == i] <- (data_cr[g == i] - median_cr[which(names(median_cr) == i)]) / sd_cr[which(names(sd_cr) == i)]
      }

      # V\u00e9rifier l'\u00e9quivalence de distribution pour \u00e9valuer la fiabilit\u00e9 de WMW si non appari\u00e9es.
      # Lehmann, E. L., & Romano, J. P. (2005). Testing Statistical Hypotheses (3\u1d49 \u00e9d.). Springer.
      # KS v\u00e9rifie l'identit\u00e9 de distribution...
      # Correction de Sidak
      pval <- 1 - (1 - alpha)^(1/length(unique(g)))
      temp <- pairwise(data_cr, g, type = "ks", boot = FALSE)
      ks_result <- min(unlist(temp$p.value), na.rm = T)

      if (ks_result < pval) {
        check_wilcox_fiability <- FALSE
        # Message masqu\u00e9 car d\u00e9j\u00e0 affich\u00e9 dans sys_one_factor_analysis.R
        .dbg(
          paste0("Kolmogorov-Smirnov test [ks.test()] on median-centered and reduced data:\n\t",
          "Warning! The data do not have the same distribution (p-value: ", .format_pval(ks_result), ")...\n\t",
          "...compared to Sidak-corrected alpha ", .format_pval(pval), ".\n\t",
          "--> The Mann-Whitney-Wilcoxon test will be less reliable.\n\t",
          "(Please verify graphically that the groups have the same distribution.)"),
          paste0("Test de Kolmogorov-Smirnov [ks.test()] sur les donn\u00e9es centr\u00e9es sur la m\u00e9diane et r\u00e9duites :\n\t",
          "Attention ! Les donn\u00e9es n'ont pas la m\u00eame distribution (p-value : ", .format_pval(ks_result), ")...\n\t",
          "...en comparant avec l'alpha corrig\u00e9 de Sidak ", .format_pval(pval), ".\n\t",
          "--> Le test de Mann-Whitney-Wilcoxon sera moins fiable.\n\t",
          "(Veuillez v\u00e9rifier graphiquement les distributions des groupes.)"),
          debug = debug
        )
      } else {
        # Message masqu\u00e9 car d\u00e9j\u00e0 affich\u00e9 dans sys_one_factor_analysis.R
        .dbg(
          paste0("Kolmogorov-Smirnov test [ks.test()] on median-centered and reduced data -\n\tThe groups have the same distribution. p-value: ", .format_pval(ks_result), "...\n\t\t...by comparing with Sidak corrected alpha ", .format_pval(pval), "\n\tThe Mann-Whitney-Wilcoxon test will be reliable."),
          paste0("Test de Kolmogorov-Smirnov [ks.test()] sur les donn\u00e9es centr\u00e9es sur la m\u00e9diane et r\u00e9duites -\n\tLes groupes ont la m\u00eame distribution. p-value : ", .format_pval(ks_result), "...\n\t\t...en comparant avec l'alpha corrig\u00e9 de Sidak ", .format_pval(pval), "\n\tLe test de Mann-Whitney-Wilcoxon est fiable a priori."),
          debug = debug
        )
      }

      #------------------------------------------
      # Annoncer les tests post-hocs avec une formulation adapt\u00e9 au nombre de groupes
      #------------------------------------------
      if (number == 2) {
        ang <- "Non-parametric comparison tests for two groups."
        fr <- "Tests non param\u00e9triques de comparaison des deux groupes."
        k <- .vbse(ang, fr, verbose = verbose, code = code, k = k, cpt = "on")
      } else {
        ang <- "Non-parametric post-hoc tests for group comparisons."
        fr <- "Tests post-hocs non param\u00e9triques de comparaison des groupes."
        k <- .vbse(ang, fr, verbose = verbose, code = code, k = k, cpt = "on")

        if (isTRUE(code)) {
          cat("# 10) Tests post-hoc\n\n")
        }
      }

    } else if (number == 2) {
      # Si 2 groupes appari\u00e9s :
      # V\u00e9rifier la sym\u00e9trie des diff\u00e9rences pour \u00e9valuer la fiabilit\u00e9 de WMW si appari\u00e9es - Miao\u2013Gel\u2013Gastwirth MGG
      # Zheng, T., & Gastwirth, J. L. (2010). On bootstrap tests of symmetry about an unknown median. Journal of Data Science, 8(3), 397\u2013412.
      # Le test MGG, robuste et bootstrapable, permet de v\u00e9rifier la sym\u00e9trie requise pour que le test de Wilcoxon appari\u00e9 (WMW) soit statistiquement valide.
      k <- .vbse(
        "Symmetry check of paired differences - Miao-Gel-Gastwirth (MGG) test.",
        "Contr\u00f4le de la sym\u00e9trie des diff\u00e9rences appari\u00e9es - Test de Miao-Gel-Gastwirth (MGG).",
        verbose = verbose, code = code, k = k
      )

      # Calculer les diff\u00e9rences
      unique_g <- levels(g)
      g1 <- unique_g[1]
      g2 <- unique_g[2]
      x1 <- x[g == g1]
      x2 <- x[g == g2]
      differences <- x1 - x2

      # Fonction pour le test MGG (bootstrap)
      mgg_test <- function(diff, iter = 1000, alpha = 0.05) {
        n <- length(diff)
        med_diff <- median(diff)
        # Centrer sur la m\u00e9diane
        centered_diff <- diff - med_diff
        # Statistique observ\u00e9e : moyenne des diff\u00e9rences centr\u00e9es
        T_obs <- mean(centered_diff)
        # Bootstrap sous H0 de sym\u00e9trie
        T_boot <- numeric(iter)
        for (i in 1:iter) {
          # Sous H0, les signes sont al\u00e9atoires
          signs <- sample(c(-1, 1), n, replace = TRUE)
          centered_boot <- abs(centered_diff) * signs
          T_boot[i] <- mean(centered_boot)
        }
        # P-value bilat\u00e9rale
        p_value <- mean(abs(T_boot) >= abs(T_obs))
        return(list(
          statistic = T_obs,
          p.value = p_value,
          median_diff = med_diff
        ))
      }

      # Effectuer le test MGG
      mgg_result <- mgg_test(differences, iter = iter, alpha = alpha)

      # Interpr\u00e9tation
      if (mgg_result$p.value < alpha) {
        check_wilcox_fiability <- FALSE
        ang <- paste0(
          "MGG symmetry test - Asymmetric differences detected (p = ",
          .format_pval(mgg_result$p.value), ").\n\t",
          "Warning! The Wilcoxon signed-rank test may be less reliable.\n\t",
          "Consider using the Sign test as an alternative."
        )
        fr <- paste0(
          "Test de sym\u00e9trie MGG - Diff\u00e9rences asym\u00e9triques d\u00e9tect\u00e9es (p = ",
          .format_pval(mgg_result$p.value), ").\n\t",
          "Attention ! Le test de Wilcoxon appari\u00e9 peut \u00eatre moins fiable.\n\t",
          "Envisagez d'utiliser le test de signe comme alternative."
        )
        k <- .vbse(ang, fr, verbose = verbose, code = code, k = k, cpt = "off")
      }
    }

    ##########
    # \u00c9chantillons non-normaux - WILCOXON
    ##########
    if (number == 2) {
      .dbg(NULL, "2 cat\u00e9gories.",
           debug = debug)

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Code
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if (isTRUE(code)) {
        cat("# Test de Wilcoxon-Mann-Witney\nwilcox.test(x[g==unique(g)[1]],x[g==unique(g)[2]],paired=", paired, ")")
      }

      pvals <- suppressWarnings(wilcox.test(x[g == g1], x[g == g2], paired = paired))$p.value
      control_chr <- if (is.null(control)) NULL else as.character(control)[1]
      ind_control <- if (is.null(control_chr)) integer(0L) else match(control_chr, lev)

      ##########
      # \u00c9chantillons appari\u00e9s \u00e0 2 niveaux
      ##########
      if (isTRUE(paired)) {
        #=====================================================
        # --- CAS APPARI\u00c9 : PAS de bootstrap "indice m\u00e9diane"
        #=====================================================
        k <- .vbse(
          "Post-hoc: paired Wilcoxon signed-rank test [wilcox.test(paired = TRUE)].",
          "Post-hoc : test de Wilcoxon appari\u00e9 [wilcox.test(paired = TRUE)].",
          verbose = verbose, code = code, k = k, cpt = "on"
        )

        if (pvals <= alpha) {
          k <- .vbse(
            paste0("Significant difference between the paired levels (p = ", .format_pval(pvals), ")."),
            paste0("Diff\u00e9rence significative entre les niveaux appari\u00e9s (p = ", .format_pval(pvals), ")."),
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        } else {
          k <- .vbse(
            paste0("No significant difference between the paired levels (p = ", .format_pval(pvals), ")."),
            paste0("Aucune diff\u00e9rence significative entre les niveaux appari\u00e9s (p = ", .format_pval(pvals), ")."),
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        }

        # Attribution des lettres et des \u00e9toiles
        synth <- list()
        if (length(ind_control) != 1L) {
          # Sans t\u00e9moin : lettres a/b
          synth$groups <- data.frame(
            categories = lev,
            Wilcoxon_Holm = if (pvals <= alpha) c("a", "b") else c("a", "a")
          )
        } else {
          # Avec t\u00e9moin : \u00e9toiles sur la cat\u00e9gorie non t\u00e9moin
          stars <- c("", "")
          stars[-ind_control] <- ifelse(pvals <= 0.001, "***",
                                        ifelse(pvals <= 0.01,  "**",
                                               ifelse(pvals <= 0.05,   "*", "")))
          synth$groups <- data.frame(
            categories = lev,
            Wilcoxon_Holm = stars
          )
        }
        synth$p.value <- pvals

        # (optionnel) robustesse bootstrap sur la m\u00e9diane
        if (isTRUE(boot)) {
          synth$bootstrap <- .boots(
            x, g,
            ctrl = (length(ind_control) == 1L),
            type = "median",
            conf = conf, iter = iter, alpha = alpha,
            paired = TRUE, control = control
          )
          colnames(synth$bootstrap$groups)[2] <- "Wilcoxon_bootstrapped"

          if ((verbose == TRUE) && any(synth$bootstrap$groups[, 2] != synth$groups[, 2])) {
            k <- .vbse(
              "Warning! Bootstrap detects weaknesses in the significance of the results.",
              "Attention ! Le bootstrap d\u00e9tecte des faiblesses dans la signification des r\u00e9sultats.",
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          }
        }

        #=====================================================
        # --- check_wilcox_fiability == FALSE, compl\u00e9ter par un test de signe avec binom.test()
        #=====================================================
        if (check_wilcox_fiability == FALSE) {
          #========================================
          # CAS APPARI\u00c9 : Diff\u00e9rences asym\u00e9triques d\u00e9tect\u00e9es par MGG
          # Alternative : Test de signe EN COMPL\u00c9MENT du Wilcoxon
          #========================================
          k <- .vbse(
            "Asymmetric differences detected - Adding Sign test as robust alternative.",
            "Diff\u00e9rences asym\u00e9triques d\u00e9tect\u00e9es - Ajout du test de signe comme alternative robuste.",
            verbose = verbose, code = code, k = k
          )

          # Calculer les diff\u00e9rences
          x1 <- x[g == g1]
          x2 <- x[g == g2]
          differences <- x1 - x2

          # Compter les diff\u00e9rences (exclure les ex-aequo)
          n_positive <- sum(differences > 0)
          n_negative <- sum(differences < 0)
          n_zero <- sum(differences == 0)
          n_total <- n_positive + n_negative  # Diff\u00e9rences non nulles

          if (n_total == 0) {
            k <- .vbse(
              "All differences are zero. Sign test cannot be performed.",
              "Toutes les diff\u00e9rences sont nulles. Le test de signe ne peut \u00eatre effectu\u00e9.",
              verbose = verbose, code = code, k = k, cpt = "off"
            )
            # Ajouter une colonne vide
            synth$groups$Sign_test <- c("a", "a")
            # p-value = 1 (aucune diff\u00e9rence)
            pvals_sign <- 1

          } else {
            # Test de signe avec binom.test()
            if (isTRUE(code)) {
              cat("# Test de signe (Sign test)\n",
                      "differences <- x[g==unique(g)[1]] - x[g==unique(g)[2]]\n",
                      "n_positive <- sum(differences > 0)\n",
                      "n_total <- sum(differences != 0)\n",
                      "binom.test(n_positive, n_total, p = 0.5, alternative = 'two.sided')\n")
            }

            k <- .vbse(
              paste0("Sign test [binom.test()] - Distribution-free test for paired data.\n\t",
                     "Positive differences: ", n_positive, ", Negative: ", n_negative,
                     ", Ties (excluded): ", n_zero),
              paste0("Test de signe [binom.test()] - Test sans hypoth\u00e8se de distribution pour donn\u00e9es appari\u00e9es.\n\t",
                     "Diff\u00e9rences positives : ", n_positive, ", N\u00e9gatives : ", n_negative,
                     ", Ex-aequo (exclus) : ", n_zero),
              verbose = verbose, code = code, k = k, cpt = "off"
            )

            # Effectuer le test binomial
            binom_result <- binom.test(n_positive, n_total, p = 0.5, alternative = "two.sided")
            pvals_sign <- binom_result$p.value

            # Attribution des lettres ou \u00e9toiles pour le test de signe
            if (length(ind_control) != 1) {
              #========================================
              # Pas de contr\u00f4le - lettres a/b
              #========================================
              if (pvals_sign <= alpha) {
                sign_groups <- c("a", "b")
                k <- .vbse(
                  paste0("Sign test: Significant difference detected (p = ", .format_pval(pvals_sign), ")."),
                  paste0("Test de signe : Diff\u00e9rence significative d\u00e9tect\u00e9e (p = ", .format_pval(pvals_sign), ")."),
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              } else {
                sign_groups <- c("a", "a")
                k <- .vbse(
                  paste0("Sign test: No significant difference (p = ", .format_pval(pvals_sign), ")."),
                  paste0("Test de signe : Aucune diff\u00e9rence significative (p = ", .format_pval(pvals_sign), ")."),
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              }

            } else {
              #========================================
              # Avec contr\u00f4le - \u00e9toiles
              #========================================
              sign_groups <- c("", "")
              sign_groups[-ind_control] <- ifelse(pvals_sign <= 0.001, "***",
                                                  ifelse(pvals_sign <= 0.01, "**",
                                                         ifelse(pvals_sign <= 0.05, "*", "")))

              if (pvals_sign <= alpha) {
                k <- .vbse(
                  paste0("Sign test: Significant difference vs control (p = ", .format_pval(pvals_sign), ")."),
                  paste0("Test de signe : Diff\u00e9rence significative vs t\u00e9moin (p = ", .format_pval(pvals_sign), ")."),
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              } else {
                k <- .vbse(
                  paste0("Sign test: No significant difference vs control (p = ", .format_pval(pvals_sign), ")."),
                  paste0("Test de signe : Aucune diff\u00e9rence significative vs t\u00e9moin (p = ", .format_pval(pvals_sign), ")."),
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              }
            }

            # AJOUTER la colonne Sign_test \u00e0 synth$groups (qui contient d\u00e9j\u00e0 Wilcoxon)
            synth$groups$Sign_test <- sign_groups

            # \u00c9CRASER synth$p.value avec la p-value du Sign test (test de r\u00e9f\u00e9rence car asym\u00e9trie)
            synth$p.value <- pvals_sign

            # Comparaison entre Wilcoxon et Sign test si divergence
            wilcox_signif <- (pvals <= alpha)
            sign_signif <- (pvals_sign <= alpha)

            if (wilcox_signif != sign_signif) {
              k <- .vbse(
                paste0("Warning! Wilcoxon and Sign tests give different conclusions.\n\t",
                       "Wilcoxon p=", .format_pval(pvals), " vs Sign p=", .format_pval(pvals_sign), "\n\t",
                       "Sign test is more reliable with asymmetric differences (synth$p.value updated)."),
                paste0("Attention ! Les tests de Wilcoxon et de signe donnent des conclusions diff\u00e9rentes.\n\t",
                       "Wilcoxon p=", .format_pval(pvals), " vs Signe p=", .format_pval(pvals_sign), "\n\t",
                       "Le test de signe est plus fiable avec des diff\u00e9rences asym\u00e9triques (synth$p.value mise \u00e0 jour)."),
                verbose = verbose, code = code, k = k, cpt = "off"
              )
            }

            # Bootstrap optionnel pour robustesse du test de signe
            if (boot == TRUE) {
              k <- .vbse(
                "Bootstrap validation of Sign test.",
                "Validation bootstrap du test de signe.",
                verbose = verbose, code = code, k = k, cpt = "off"
              )

              boot_pvals <- numeric(iter)
              for (i in 1:iter) {
                # R\u00e9\u00e9chantillonner les paires
                indices <- sample(1:length(differences), replace = TRUE)
                diff_boot <- differences[indices]
                non_zero_boot <- diff_boot[diff_boot != 0]

                if (length(non_zero_boot) > 0) {
                  n_pos_boot <- sum(non_zero_boot > 0)
                  boot_pvals[i] <- binom.test(n_pos_boot, length(non_zero_boot),
                                              p = 0.5, alternative = "two.sided")$p.value
                } else {
                  boot_pvals[i] <- 1
                }
              }

              # Proportion significative
              boot_significant <- sum(boot_pvals <= alpha) / iter

              # Ajouter \u00e0 synth$bootstrap (qui existe d\u00e9j\u00e0 pour Wilcoxon)
              if (is.null(synth$bootstrap)) {
                synth$bootstrap <- list()
              }
              synth$bootstrap$sign_proportion_significant <- boot_significant
              synth$bootstrap$sign_median_pvalue <- median(boot_pvals)

              # Ajouter colonne bootstrap Sign_test
              if (length(ind_control) != 1) {
                # Lettres selon le bootstrap
                sign_boot_groups <- if (boot_significant >= 0.95) sign_groups else c("a", "a")
              } else {
                # \u00c9toiles selon le bootstrap
                sign_boot_groups <- if (boot_significant >= 0.95) sign_groups else c("", "")
              }

              # Cr\u00e9er ou compl\u00e9ter synth$bootstrap$groups
              if (is.null(synth$bootstrap$groups)) {
                synth$bootstrap$groups <- data.frame(categories = lev)
              }
              synth$bootstrap$groups$Sign_test_bootstrapped <- sign_boot_groups

              if (boot_significant < 0.95 && pvals_sign <= alpha) {
                k <- .vbse(
                  paste0("Warning! Bootstrap shows instability for Sign test: only ",
                         round(boot_significant * 100, 1), "% of iterations significant."),
                  paste0("Attention ! Bootstrap montre une instabilit\u00e9 pour le test de signe : seulement ",
                         round(boot_significant * 100, 1), "% d'it\u00e9rations significatives."),
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              }
            }
          }

          # Note acad\u00e9mique
          k <- .vbse(
            "Note: Sign test is the only UMP (Uniformly Most Powerful) invariant test when symmetry is not guaranteed (Lehmann & Romano, 2005).",
            "Note : Le test de signe est le seul test UMP (Uniformly Most Powerful) invariant lorsque la sym\u00e9trie n'est pas garantie (Lehmann & Romano, 2005).",
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        }

      } else {
        # Si non appari\u00e9
        #=====================================================
        #       Si non appari\u00e9
        #=====================================================

        # a) Bootstrap sur l'indice moyen
        k <- .vbse(
          "a) Posthoc - Analysis of median differences by bootstrap [pairwise.boot(mu='median') from {KefiR}].",
          "a) Posthoc - Analyse des diff\u00e9rences de m\u00e9dianes par bootstrap [pairwise.boot(mu='median') de {KefiR}]",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        # Utiliser boot_type sp\u00e9cifi\u00e9 ou la logique automatique
        final_boot_type <- if (!is.null(boot_type)) boot_type else "median"
        synth2 <- pairwise(x, g, type = "boot", alpha = alpha, control = control, boot = FALSE,
                           boot_type = final_boot_type, conf = conf, iter = iter, debug = debug)

        # b) Test de Wilcoxon
        k <- .vbse(
          "b) Post-hoc - Test de Wilcoxon-Mann-Whitney [wilcox.test()].",
          "b) Posthoc - Test de Wilcoxon-Mann-Witney [wilcox.test()].",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        if (length(ind_control) != 1) {
          ##########
          #	Pas de contr\u00f4le
          ##########
          synth <- list()
          if (pvals <= alpha) {
            synth$groups <- data.frame(categories = lev, Wilcoxon = c("a", "b"))
          } else {
            synth$groups <- data.frame(categories = lev, Wilcoxon = c("a", "a"))
          }
          synth$p.value <- pvals

        } else {
          ##########
          #	Contr\u00f4le
          ##########
          synth <- list()
          stars <- c("", "")
          stars[-ind_control] <- ifelse(pvals <= 0.001, "***",
                                        ifelse(pvals <= 0.01, "**",
                                               ifelse(pvals <= 0.05, "*", "")))
          synth$groups <- data.frame(categories = lev, Wilcoxon = stars)
          synth$p.value <- pvals
        }

        if (boot == TRUE) {
          synth$bootstrap <- .boots(
            x, g,
            ctrl = (length(ind_control) == 1),
            type = "median", conf = conf, iter = iter, alpha = alpha,
            paired = paired, control = control
          )
          colnames(synth$bootstrap$groups)[2] <- "Wilcoxon_bootstrapped"
        }

        if ((boot == TRUE) & any(synth$bootstrap$groups[, 2] != synth$groups[, 2])) {
          k <- .vbse(
            "Warning! Bootstrap detects weaknesses in the significance of the results.",
            "Attention ! Le bootstrap d\u00e9tecte des faiblesses dans la signification des r\u00e9sultats.",
            k = k, cpt = "off"
          )
        }

        # Ajout du bootstrap sur la m\u00e9diane
        ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
        synth$groups <- data.frame(
          "categories" = synth$groups[, 1],
          "Bootstrap" = synth2$groups[ind_temp, 2],
          "Wilcoxon_Holm" = synth$groups[, 2]
        )

        #=====================================================
        # --- check_wilcox_fiability == FALSE
        # Distributions diff\u00e9rentes d\u00e9tect\u00e9es par KS
        # Alternative : Test de Brunner-Munzel
        #=====================================================
        if (check_wilcox_fiability == FALSE) {
          k <- .vbse(
            "Different distributions detected by KS test\n\t==> Brunner-Munzel test added as robust alternative.",
            "Distributions diff\u00e9rentes d\u00e9tect\u00e9es par le test KS\n\t==> Test de Brunner-Munzel ajout\u00e9 comme alternative robuste.",
            verbose = verbose, code = code, k = k
          )

          # c) Test de Brunner-Munzel
          if (isTRUE(code)) {
            cat("# Test de Brunner-Munzel\n",
                    "pairwise(x, g, type='BM', alpha=", alpha,
                    if (length(ind_control) == 1) paste0(", control='", control, "'") else "", ")\n")
          }

          # Appel \u00e0 pairwise() avec type="BM" (fonctionne pour 2 groupes ou plus)
          synth_BM <- pairwise(x, g, type = "BM", alpha = alpha, control = control,
                               boot = boot, conf = conf, iter = iter, debug = debug)

          # V\u00e9rifier que pairwise a r\u00e9ussi
          if (!is.null(synth_BM) && !is.null(synth_BM$groups)) {

            # AJOUTER la colonne Brunner-Munzel aux groupes existants
            ind_temp <- match(synth$groups[, 1], synth_BM$groups[, 1])

            if (number == 2) {
              synth$groups$`Brunner-Munzel` <- synth_BM$groups[ind_temp, 2]
            } else {
              synth$groups$`Brunner-Munzel_Holm` <- synth_BM$groups[ind_temp, 2]
            }

            # \u00c9CRASER synth$p.value avec la p-value/matrice de Brunner-Munzel
            synth$p.value <- synth_BM$p.value

            # Afficher r\u00e9sultat du test de Brunner-Munzel
            if (number == 2) {
              # Pour 2 groupes: afficher r\u00e9sultat avec conclusion
              # TOUJOURS afficher ce message (verbose=TRUE) m\u00eame si .posthoc() est en mode silencieux
              # car c'est un test suppl\u00e9mentaire non mentionn\u00e9 dans .one_factor_analysis()
              BM_signif <- (synth_BM$p.value <= alpha)
              k <- .vbse(
                paste0("c) Posthoc - Brunner-Munzel test [brunner.munzel.test()].\n\t",
                       if (BM_signif) "\t==> Significant differences between groups (p = " else "\t==> No significant differences between groups (p = ",
                       .format_pval(synth_BM$p.value), ")."),
                paste0("c) Posthoc - Test de Brunner-Munzel [brunner.munzel.test()].\n\t",
                       if (BM_signif) "\t==> Diff\u00e9rences significatives entre les groupes (p = " else "\t==> Pas de diff\u00e9rences significatives entre les groupes (p = ",
                       .format_pval(synth_BM$p.value), ")."),
                verbose = TRUE, k = k, cpt = "off"  # Force display even in silent mode
              )
            }

            # Comparaison Wilcoxon vs Brunner-Munzel (pour 2 groupes)
            if (number == 2) {
              wilcox_signif <- (pvals <= alpha)
              BM_signif <- (synth_BM$p.value <= alpha)

              if (wilcox_signif != BM_signif) {
                k <- .vbse(
                  paste0("Warning! Wilcoxon and Brunner-Munzel tests give different conclusions.\n\t",
                         "Wilcoxon p = ", .format_pval(pvals), " vs Brunner-Munzel p = ", .format_pval(synth_BM$p.value), "\n\t",
                         "\u2192 Brunner-Munzel is more reliable with different distributions.\n\t",
                         "\u2192 synth$p.value now contains Brunner-Munzel p-value (reference test)."),
                  paste0("Attention ! Les tests de Wilcoxon et de Brunner-Munzel donnent des conclusions diff\u00e9rentes.\n\t",
                         "Wilcoxon p = ", .format_pval(pvals), " vs Brunner-Munzel p = ", .format_pval(synth_BM$p.value), "\n\t",
                         "\u2192 Brunner-Munzel est plus fiable avec des distributions diff\u00e9rentes.\n\t",
                         "\u2192 synth$p.value contient maintenant la p-value de Brunner-Munzel (test de r\u00e9f\u00e9rence)."),
                  verbose = TRUE, k = k, cpt = "off"  # Force display even in silent mode
                )
              } else {
                k <- .vbse(
                  paste0("Wilcoxon and Brunner-Munzel tests agree (both ",
                         if (BM_signif) "significant" else "non-significant",
                         ", p-value (BM) = ", .format_pval(synth_BM$p.value), ")."),
                  paste0("Les tests MWW et de Brunner-Munzel concordent (p-value (BM) = ",
                         .format_pval(synth_BM$p.value), ")."),
                  verbose = TRUE, k = k, cpt = "off"  # Force display even in silent mode
                )
              }
            }

            # Ajouter le bootstrap de BM si disponible
            if (boot == TRUE && !is.null(synth_BM$bootstrap)) {

              # Compl\u00e9ter synth$bootstrap$groups avec les r\u00e9sultats BM
              if (is.null(synth$bootstrap$groups)) {
                synth$bootstrap$groups <- data.frame(categories = lev)
              }

              ind_temp_boot <- match(synth$bootstrap$groups[, 1], synth_BM$bootstrap$groups[, 1])

              if (number == 2) {
                synth$bootstrap$groups$`Brunner-Munzel_bootstrapped` <- synth_BM$bootstrap$groups[ind_temp_boot, 2]
              } else {
                synth$bootstrap$groups$`Brunner-Munzel_Holm_bootstrapped` <- synth_BM$bootstrap$groups[ind_temp_boot, 2]
              }

              # V\u00e9rifier si divergence entre Wilcoxon bootstrap et BM bootstrap
              if (any(synth$bootstrap$groups[, 2] != synth_BM$bootstrap$groups[ind_temp_boot, 2], na.rm = TRUE)) {
                k <- .vbse(
                  "\tWarning! Bootstrap on Brunner-Munzel shows differences with Wilcoxon bootstrap.",
                  "\tAttention ! Bootstrap sur Brunner-Munzel montre des diff\u00e9rences avec le bootstrap de Wilcoxon.",
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              }
            }

          } else {
            k <- .vbse(
              "Error! pairwise(type='BM') failed. Keeping only Wilcoxon results.",
              "Erreur ! pairwise(type='BM') a \u00e9chou\u00e9. Conservation uniquement des r\u00e9sultats de Wilcoxon.",
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          }

          # Note acad\u00e9mique
          k <- .vbse(
            "Note: Brunner-Munzel test does not assume identical distributions, unlike Wilcoxon-Mann-Whitney.",
            "Note : Le test BM ne suppose pas de distributions identiques, contrairement \u00e0 MWW.",
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        }
      }

      #=======================================================
      #         Plus de 2 cat\u00e9gories, non param\u00e9triques
      #=======================================================
    } else if (number > 2) {
      .dbg(NULL, ".posthoc() - '>2 cat\u00e9gories'.",
           debug = debug)
      # Helper: safe outlier detection with fallback
      .safe_identify_outliers <- function(data) {
        if (requireNamespace("rstatix", quietly = TRUE)) {
          return(rstatix::identify_outliers(data))
        } else {
          # Fallback: IQR method
          x <- data[[1]]
          Q1 <- quantile(x, 0.25, na.rm = TRUE)
          Q3 <- quantile(x, 0.75, na.rm = TRUE)
          IQR <- Q3 - Q1
          lower_bound <- Q1 - 1.5 * IQR
          upper_bound <- Q3 + 1.5 * IQR
          lower_extreme <- Q1 - 3 * IQR
          upper_extreme <- Q3 + 3 * IQR

          return(data.frame(
            data,
            is.outlier = (x < lower_bound | x > upper_bound),
            is.extreme = (x < lower_extreme | x > upper_extreme)
          ))
        }
      }

      # D\u00e9tection des outliers
      outlier <- function(z) {
        tablo_outlier <- .safe_identify_outliers(data.frame(z))
        if (nrow(tablo_outlier) > 0) {
          small_outliers <- tablo_outlier[tablo_outlier[, 1] < median(z), 1]
          big_outliers <- tablo_outlier[tablo_outlier[, 1] > median(z), 1]
          small_outliers <- length(small_outliers) / length(z)
          big_outliers <- length(big_outliers) / length(z)
          return(max(c(small_outliers, big_outliers)))
        } else {
          return(0)
        }
      }

      #------------------------------------------
      # 0) Identifier les outliers
      #------------------------------------------
      trimmage <- max(by(x, g, outlier))
      if (trimmage > 0) {
        .dbg("Warning! Groups with extreme values:\n\t==> risk of leverage (identify_outliers() of {rstatix}).",
          "Attention ! Groupes avec des valeurs extr\u00eames :\n\t==> risque d'effet de levier (identify_outliers() de {rstatix}).",
          debug = debug
        )
      }

      #------------------------------------------
      # 0) Croisements - Voir le nombre de paires \u00e0 analyser...
      #------------------------------------------
      croisement <- ng * (ng - 1) / 2
      if (croisement > 28) {
        .dbg(
          paste0("Posthoc - Warning! Many cross-tests to perform.\n\t\t", ng, " categories for ", croisement, " pairwise comparisons."),
          paste0("Posthoc - Attention ! Beaucoup de tests crois\u00e9s \u00e0 r\u00e9aliser.\n\t\t", ng, " cat\u00e9gories pour ", croisement, " croisements"),
          debug = debug
        )
      }

      #------------------------------------------
      # 0) Bootstrap sur l'indice median (Wilcoxon)
      #------------------------------------------
      if (isTRUE(code)) {
        cat("# Analyse des diff\u00e9rences de m\u00e9dianes par bootstrap\npairwise(x,g,type='boot')")
      }

      k <- .vbse(
        "a) Posthoc - Analysis of median differences using bootstrap [pairwise.boot() from {KefiR}].",
        "a) Posthoc - Analyse des diff\u00e9rences de m\u00e9dianes par bootstrap [pairwise.boot() de {KefiR}].",
        verbose = verbose, code = code, k = k, cpt = "off"
      )

      # Utiliser boot_type sp\u00e9cifi\u00e9 ou la logique automatique
      final_boot_type <- if (!is.null(boot_type)) boot_type else "median"
      synth2 <- pairwise(x, g, type = "boot", alpha = alpha, control = control, boot = FALSE,
                         boot_type = final_boot_type, conf = conf, iter = iter, debug = debug)

      # 1) Faire un Wilcoxon (position 1) en pairwise avec Holm
      if (isTRUE(code)) {
        cat("# Wilcoxon par paires#pairwise.wilcox.test(x,g,p.adjust.method='BH')\n")
      }

      k <- .vbse(
        "b) Posthoc - Wilcoxon-Mann-Whitney test [pairwise.wilcox.test()].",
        "b) Posthoc - Test de Wilcoxon-Mann-Whitney [pairwise.wilcox.test()].",
        verbose = verbose, code = code, k = k, cpt = "off"
      )

      synth <- pairwise(x, g, type = "median", alpha = alpha, control = control, boot = boot, conf = conf, iter = iter, paired = paired, debug = debug)
      colnames(synth$groups)[2] <- "Wilcoxon_Holm"

      # Agglom\u00e9ra du bootstrap median bootstrap sur colonne 2, Wilcoxon sur colonne 3
      ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
      synth$groups <- data.frame(
        "categories" = synth$groups[, 1],
        "Bootstrap" = synth2$groups[ind_temp, 2],
        "Wilcoxon_Holm" = synth$groups[, 2]
      )

      # Plus bootstrap int\u00e9gr\u00e9
      if (boot == TRUE) {
        if (any(synth$bootstrap$groups[, 2] != synth$groups[, 3])) {
          k <- .vbse(
            "\tWarning! Bootstrap detects weaknesses in the significance of the results.",
            "\tAttention ! Le bootstrap d\u00e9tecte des faiblesses dans la signification des r\u00e9sultats.",
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        }
        colnames(synth$bootstrap$groups)[2] <- "Wilcoxon_Holm_bootstrapped"
      }

      if (paired == TRUE) {
        if (isTRUE(code)) {
          cat("# Nemenyi - post-hoc sur donn\u00e9es appari\u00e9es\nlibrary(PMCMRplus)\nfrdAllPairsNemenyiTest(x~g)\n")
        }

        k <- .vbse(
          "c) Posthoc - Paired groups [frdAllPairsNemenyiTest() of {PMCMRplus}].",
          "c) Posthoc - Test post-hoc sur groupes non normaux appari\u00e9s [frdAllPairsNemenyiTest() of {PMCMRplus}].",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        # Donn\u00e9es appari\u00e9es, faire un Neminye
        synth2 <- pairwise(x, g, type = "neminye", alpha = alpha, control = control, boot = boot, conf = conf, iter = iter, paired = paired, debug = debug)

        ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
        colnames(synth2$groups)[2] <- "Neminyi"
        synth$groups <- cbind(synth$groups, "Neminyi" = synth2$groups[ind_temp, 2])

        if (boot == TRUE) {
          if (any(synth2$bootstrap$groups[, 2] != synth2$groups[, 2])) {
            k <- .vbse(
              "\tWarning! Bootstrap on Neminyi- weaknesses.",
              "\tAttention ! Bootstrap sur Neminyi - faiblesses.",
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          }
          colnames(synth2$bootstrap$groups)[2] <- "Neminyi_bootstrapped"
          synth$bootstrap$groups <- cbind(synth$bootstrap$groups, "Neminyi_bootstrapped" = synth2$bootstrap$groups[ind_temp, 2])
        }
      }

      #------------------------------------------
      # DONN\u00c9ES NON APPARI\u00c9ES: Brunner-Munzel si distributions diff\u00e9rentes (PRIORITAIRE)
      #------------------------------------------
      if ((paired == FALSE) && (check_wilcox_fiability == FALSE)) {
        #=====================================================
        # K GROUPES - Distributions diff\u00e9rentes d\u00e9tect\u00e9es
        # Wilcoxon et Dunn non fiables
        # Alternative : Brunner-Munzel
        # Le message d'annonce est d\u00e9j\u00e0 affich\u00e9 dans sys_one_factor_analysis.R (\u00e9tape 10 - test KS)
        #=====================================================

        if (isTRUE(code)) {
          cat("# Test de Brunner-Munzel par paires avec correction de Holm\n",
                  "# Pour chaque paire de groupes :\n",
                  "library(lawstat)\n",
                  "# Exemple pour groupes 1 et 2 :\n",
                  "brunner.munzel.test(x[g==levels(g)[1]], x[g==levels(g)[2]])\n",
                  "# R\u00e9p\u00e9ter pour toutes les paires (i,j) o\u00f9 i < j\n",
                  "# Puis appliquer la correction de Holm sur toutes les p-values :\n",
                  "p.adjust(p_values_vector, method='holm')\n")
        }

        k <- .vbse(
          "c) Posthoc - Brunner-Munzel pairwise test [brunner.munzel.test() from {lawstat}, Holm correction].",
          "c) Posthoc - Test de Brunner-Munzel par paires [brunner.munzel.test() de {lawstat}, correction de Holm].",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        # Appel \u00e0 pairwise() avec type="BM" (en interne, utilise lawstat::brunner.munzel.test)
        synth_BM <- pairwise(x, g, type = "BM", alpha = alpha, control = control,
                             boot = boot, conf = conf, iter = iter, debug = debug)

        # V\u00e9rifier que pairwise a r\u00e9ussi
        if (!is.null(synth_BM) && !is.null(synth_BM$groups)) {

          # AJOUTER la colonne Brunner-Munzel aux groupes existants (apr\u00e8s Wilcoxon/Dunn/Lincon)
          ind_temp <- match(synth$groups[, 1], synth_BM$groups[, 1])
          synth$groups$`Brunner-Munzel_Holm` <- synth_BM$groups[ind_temp, 2]

          # \u00c9CRASER synth$p.value avec la matrice de p-values de Brunner-Munzel
          # (BM devient la r\u00e9f\u00e9rence car plus fiable avec distributions diff\u00e9rentes)
          synth$p.value <- synth_BM$p.value

          .dbg(
            "Brunner-Munzel test completed. p-values updated (synth$p.value now contains BM p-values matrix).",
            "Test de Brunner-Munzel termin\u00e9. p-values mises \u00e0 jour (synth$p.value contient maintenant la matrice BM).",
            debug = debug
          )

          # Ajouter le bootstrap de BM si disponible
          if (boot == TRUE && !is.null(synth_BM$bootstrap) && !is.null(synth_BM$bootstrap$groups)) {

            # Compl\u00e9ter synth$bootstrap$groups avec les r\u00e9sultats BM
            if (is.null(synth$bootstrap$groups)) {
              synth$bootstrap$groups <- data.frame(categories = lev)
            }

            ind_temp_boot <- match(synth$bootstrap$groups[, 1], synth_BM$bootstrap$groups[, 1])

            # V\u00e9rifier que les indices sont valides
            if (!all(is.na(ind_temp_boot)) && length(ind_temp_boot) > 0) {
              # Utiliser cbind au lieu de $ pour \u00e9viter probl\u00e8mes avec backticks
              synth$bootstrap$groups <- cbind(
                synth$bootstrap$groups,
                "Brunner-Munzel_Holm_bootstrapped" = synth_BM$bootstrap$groups[ind_temp_boot, 2]
              )

              # V\u00e9rifier si divergence entre les tests pr\u00e9c\u00e9dents et BM bootstrap
              # Comparer avec la premi\u00e8re colonne de r\u00e9sultats (g\u00e9n\u00e9ralement Wilcoxon_Holm ou Dunn_Holm)
              if (ncol(synth$bootstrap$groups) >= 3) {
                if (any(synth$bootstrap$groups[, 2] != synth$bootstrap$groups[, ncol(synth$bootstrap$groups)], na.rm = TRUE)) {
                k <- .vbse(
                  "\tWarning! Bootstrap on Brunner-Munzel shows differences with previous bootstrap results.",
                  "\tAttention ! Bootstrap sur Brunner-Munzel montre des diff\u00e9rences avec les r\u00e9sultats bootstrap pr\u00e9c\u00e9dents.",
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              } else {
                .dbg(
                  "\tBootstrap confirms consistency between tests.",
                  "\tBootstrap confirme la coh\u00e9rence entre les tests.",
                  debug = debug
                )
              }
            }
            } else {
              .dbg(
                "Warning: Could not match bootstrap groups for Brunner-Munzel. Skipping bootstrap comparison.",
                "Attention : Impossible de faire correspondre les groupes bootstrap pour Brunner-Munzel. Comparaison bootstrap ignor\u00e9e.",
                debug = debug
              )
            }
          }

          # Comparaison des conclusions entre les diff\u00e9rents tests
          # V\u00e9rifier si Wilcoxon/Dunn et BM donnent les m\u00eames groupes
          n_cols <- ncol(synth$groups)
          if (n_cols >= 3 && !is.null(synth$groups$`Brunner-Munzel_Holm`) && length(synth$groups$`Brunner-Munzel_Holm`) > 0) {
            # Comparer la derni\u00e8re colonne BM avec les pr\u00e9c\u00e9dentes (Wilcoxon, Dunn, etc.)
            differences_detected <- FALSE

            for (col_idx in 2:(n_cols - 1)) {
              # V\u00e9rifier que la colonne existe et n'est pas vide
              if (length(synth$groups[, col_idx]) > 0 && !all(is.na(synth$groups[, col_idx]))) {
                if (any(synth$groups[, col_idx] != synth$groups$`Brunner-Munzel_Holm`, na.rm = TRUE)) {
                  differences_detected <- TRUE
                  break
                }
              }
            }

            if (differences_detected) {
              k <- .vbse(
                paste0("Warning! Brunner-Munzel gives different groupings than other tests.\n\t",
                       "\u2192 Brunner-Munzel is more reliable with different distributions.\n\t",
                       "\u2192 Prioritize Brunner-Munzel results (rightmost column)."),
                paste0("Attention ! Brunner-Munzel donne des groupements diff\u00e9rents des autres tests.\n\t",
                       "\u2192 Brunner-Munzel est plus fiable avec des distributions diff\u00e9rentes.\n\t",
                       "\u2192 Prioriser les r\u00e9sultats de Brunner-Munzel (colonne la plus \u00e0 droite)."),
                verbose = verbose, code = code, k = k, cpt = "off"
              )
            } else {
              .dbg(
                "All tests agree on group classifications.",
                "Tous les tests concordent sur les classifications de groupes.",
                debug = debug
              )
            }
          }

        } else {
          k <- .vbse(
            "Error! Brunner-Munzel pairwise test failed. Keeping previous test results (Wilcoxon/Dunn/Lincon).",
            "Erreur ! Test de Brunner-Munzel par paires \u00e9chou\u00e9. Conservation des r\u00e9sultats des tests pr\u00e9c\u00e9dents (Wilcoxon/Dunn/Lincon).",
            verbose = verbose, code = code, k = k, cpt = "off"
          )
        }

        # Note acad\u00e9mique masqu\u00e9e (debug uniquement)
        .dbg(
          paste0("Academic note: With different distributions detected, Brunner-Munzel test is preferable.\n\t",
                 "Wilcoxon-Mann-Whitney and Dunn tests assume identical distributions (location shift only).\n\t",
                 "Brunner-Munzel makes no such assumption and remains valid (Brunner & Munzel, 2000)."),
          paste0("Note acad\u00e9mique : Avec des distributions diff\u00e9rentes d\u00e9tect\u00e9es, le test de Brunner-Munzel est pr\u00e9f\u00e9rable.\n\t",
                 "Les tests de Wilcoxon-Mann-Whitney et Dunn supposent des distributions identiques (d\u00e9calage de position uniquement).\n\t",
                 "Brunner-Munzel ne fait pas cette hypoth\u00e8se et reste valide (Brunner & Munzel, 2000)."),
          debug = debug
        )
      }

      #------------------------------------------
      # DONN\u00c9ES NON APPARI\u00c9ES: Post-hoc adapt\u00e9 selon chosen_test
      #------------------------------------------
      if (paired == FALSE) {
        # D\u00e9terminer le post-hoc appropri\u00e9 selon le test global utilis\u00e9

        if (!is.null(chosen_test) && chosen_test == "med1way") {
          #------------------------------------------
          # Post-hoc pour med1way() : medpb2 percentile bootstrap (WRS2)
          #------------------------------------------
          if (isTRUE(code)) {
            cat("# Post-hoc robuste pour m\u00e9dianes avec medpb2 (WRS2)\n",
                "# Comparaisons par paires avec percentile bootstrap\n",
                "library(WRS2)\n",
                "library(KefiR)  # Pour .pairwise_medpb2()\n",
                "result_medpb2 <- .pairwise_medpb2(x, g, alpha = ", alpha, ", nboot = ", iter, ")\n")
          }

          k <- .vbse(
            "c) Posthoc - Robust median comparisons [medpb2() from {WRS2}, Holm correction].",
            "c) Posthoc - Comparaisons robustes de m\u00e9dianes [medpb2() de {WRS2}, correction de Holm].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          # Appeler wrapper medpb2
          synth_medpb2 <- tryCatch({
            # V\u00e9rifier que la fonction existe
            if (!exists(".pairwise_medpb2", mode = "function")) {
              stop(".pairwise_medpb2() function not found. Did you source R/sys_pairwise_medpb2.R?")
            }
            .pairwise_medpb2(x, g, alpha = alpha, control = control, nboot = iter, debug = debug)
          }, error = function(e) {
            # Message d'erreur plus d\u00e9taill\u00e9
            if (isTRUE(verbose)) {
              message("ERROR in .pairwise_medpb2(): ", e$message)
            }
            .dbg(paste0("Error in .pairwise_medpb2(): ", e$message),
                 paste0("Erreur dans .pairwise_medpb2() : ", e$message),
                 debug = debug)
            return(NULL)
          })

          # Ajouter les r\u00e9sultats \u00e0 synth$groups
          if (!is.null(synth_medpb2) && !is.null(synth_medpb2$groups)) {
            ind_temp <- match(synth$groups[, 1], synth_medpb2$groups[, 1])
            synth$groups <- cbind(synth$groups, medpb2_Holm = synth_medpb2$groups[ind_temp, 2])
          } else {
            k <- .vbse(
              "\t\tWarning! medpb2 pairwise test failed. Relying on previous tests (Bootstrap, Wilcoxon).",
              "\t\tAttention ! Test medpb2 par paires \u00e9chou\u00e9. Utilisation des tests pr\u00e9c\u00e9dents (Bootstrap, Wilcoxon).",
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          }

          # Pour med1way, on s'arr\u00eate l\u00e0 (pas de lincon ni Dunn)

        } else if (!is.null(chosen_test) && chosen_test == "kruskal") {
          #------------------------------------------
          # Post-hoc pour Kruskal-Wallis : Dunn test
          #------------------------------------------
          if (isTRUE(code)) {
            cat("# Test de Dunn\nlibrary(FSA)\ndunnTest(x ~ g, method = 'holm')\n")
          }

          k <- .vbse(
            "c) Posthoc - Dunn test [dunnTest() of {FSA}].",
            "c) Posthoc - Test de Dunn [dunnTest() de {FSA}].",
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          synth2 <- pairwise(x, g, type = "dunn", alpha = alpha, control = control, boot = boot,
                             conf = conf, iter = iter, debug = debug)

          if (!is.null(synth2) && !is.null(synth2$groups) && nrow(synth2$groups) > 0) {
            ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
            synth$groups <- data.frame(synth$groups, "Dunn_Holm" = synth2$groups[ind_temp, 2])

            if (boot == TRUE && !is.null(synth2$bootstrap) && !is.null(synth2$bootstrap$groups)) {
              if (any(synth$bootstrap$groups[, 2] != synth$groups[, 2], na.rm = TRUE)) {
                k <- .vbse(
                  "\t\tWarning! Bootstrap on Dunn test detects weaknesses.",
                  "\t\tAttention ! Bootstrap sur le test de Dunn d\u00e9tecte des faiblesses.",
                  verbose = verbose, code = code, k = k, cpt = "off"
                )
              }
              synth$bootstrap$groups <- data.frame(synth$bootstrap$groups, "Dunn_Holm_bootstrapped" = synth2$bootstrap$groups[ind_temp, 2])
            }
          }

          # Pour Kruskal, on s'arr\u00eate l\u00e0 (pas de lincon)

        } else if ((trimmage > 0) && (croisement < 28)) {
          #------------------------------------------
          # Post-hoc pour t1way() ou par d\u00e9faut : lincon() sur moyennes tronqu\u00e9es
          #------------------------------------------
          if (isTRUE(code)) {
            cat("# Lincon - comparaisons robustes sur moyennes tronqu\u00e9es\n",
                "library(WRS2)\n",
                "lincon(x ~ g, tr = ", round(trimmage, 3), ")\n")
          }

          k <- .vbse(
            paste0("c) Posthoc - Robust comparisons on trimmed means [lincon() from {WRS2}].\n",
                   "\t\tTrimming level: ", round(trimmage * 100, 1), "% (lower and upper)."),
            paste0("c) Posthoc - Comparaisons robustes sur moyennes tronqu\u00e9es [lincon() de {WRS2}].\n",
                   "\t\tNiveau de troncature : ", round(trimmage * 100, 1), "% (inf\u00e9rieur et sup\u00e9rieur)."),
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          # Faire un lincon() sur donn\u00e9es trimm\u00e9es
          synth2 <- pairwise(x, g, type = "lincon", tr = trimmage,
                             alpha = alpha, control = control, boot = boot,
                             conf = conf, iter = iter, debug = debug)

          # V\u00e9rifier que pairwise a r\u00e9ussi
          if (!is.null(synth2) && !is.null(synth2$groups) && nrow(synth2$groups) > 0) {
            ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])

            if (!all(is.na(ind_temp)) && length(ind_temp) > 0) {
              # Nom de la colonne : Lincon
              colnames(synth2$groups)[2] <- "Lincon"
              synth$groups <- cbind(synth$groups, Lincon = synth2$groups[ind_temp, 2])

              if (boot == TRUE && !is.null(synth2$bootstrap) && !is.null(synth2$bootstrap$groups)) {
                if (ncol(synth$bootstrap$groups) >= 2 && length(synth$groups[, 2]) > 0) {
                  if (any(synth$bootstrap$groups[, 2] != synth$groups[, 2], na.rm = TRUE)) {
                    k <- .vbse(
                      "\t\tWarning! Bootstrap on Lincon - weaknesses.",
                      "\t\tAttention ! Bootstrap sur Lincon - faiblesses.",
                      verbose = verbose, code = code, k = k, cpt = "off"
                    )
                  }
                }
                colnames(synth2$bootstrap$groups)[2] <- "Lincon_bootstrapped"
                synth$bootstrap$groups <- cbind(synth$bootstrap$groups, "Lincon_bootstrapped" = synth2$bootstrap$groups[ind_temp, 2])
              }
            }
          } else {
            k <- .vbse(
              "\t\tWarning! Lincon test failed or returned no results.",
              "\t\tAttention ! Le test Lincon a \u00e9chou\u00e9 ou n'a pas retourn\u00e9 de r\u00e9sultats.",
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          }
        }
      }

      #------------------------------------------
      # FALLBACK: Test de Dunn (si ni medpb2 ni lincon ni Kruskal d\u00e9j\u00e0 trait\u00e9)
      #------------------------------------------
      if ((paired == FALSE) && (check_wilcox_fiability == TRUE) &&
          !((trimmage > 0) && (croisement < 28)) &&
          !(chosen_test %in% c("med1way", "kruskal"))) {
        # Test de Dunn avec correction de Holm
        if (isTRUE(code)) {
          cat("# Test de Dunn\nlibrary(FSA)\ndunnTest(x ~ g, method = 'holm')\n")
        }

        k <- .vbse(
          "c) Posthoc - Dunn test [dunnTest() of {FSA}].",
          "c) Posthoc - Test de Dunn [dunnTest() de {FSA}].",
          verbose = verbose, code = code, k = k, cpt = "off"
        )

        if (trimmage > 0) {
          k <- .vbse(
            paste0("\tLower and upper trimming level of ", round(trimmage * 100, 1), "%."),
            paste0("\tAvec troncature inf\u00e9rieure et sup\u00e9rieure de ", round(trimmage * 100, 1), "%."),
            verbose = verbose, code = code, k = k, cpt = "off"
          )

          x_temp <- c()
          g_temp <- c()
          for (categor in lev) {
            x_categor <- x[g == categor]
            x_categor <- x_categor[x_categor > quantile(x_categor, p = trimmage) & x_categor < quantile(x_categor, p = (1 - trimmage))]
            g_categor <- rep(categor, length(x_categor))
            x_temp <- c(x_temp, x_categor)
            g_temp <- c(g_temp, g_categor)
          }
        } else {
          x_temp <- x
          g_temp <- g
        }

        synth2 <- pairwise(x_temp, g_temp, type = "dunn", alpha = alpha, control = control, boot = boot,
                           conf = conf, iter = iter, debug = debug)

        ind_temp <- match(synth$groups[, 1], synth2$groups[, 1])
        synth$groups <- data.frame(synth$groups, "Dunn_Holm" = synth2$groups[ind_temp, 2])

        if (boot == TRUE) {
          if (any(synth$bootstrap$groups[, 2] != synth$groups[, 2])) {
            k <- .vbse(
              "\tWarning! Bootstrap on Dunn test detects weaknesses.",
              "\tAttention ! Bootstrap sur le test de Dunn d\u00e9tecte des faiblesses.",
              verbose = verbose, code = code, k = k, cpt = "off"
            )
          }
          synth$bootstrap$groups <- data.frame(synth$bootstrap$groups, "Dunn_Holm_bootstrapped" = synth2$bootstrap$groups[ind_temp, 2])
        }
      }
    }
  }

  synth <- structure(
    synth,
    class = "posthoc"
  )

  .dbg(NULL, "Fin de .posthoc().",
       debug = debug)

  return(synth)
}
